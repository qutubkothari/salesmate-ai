const { supabase } = require('./config');
const { getDiscountSlab, DISCOUNT_SLABS } = require('./volumeDiscountService');

/**
 * Extract quantity from discount message
 * e.g., "i need 100 ctns give me more discount" -> 100
 */
function extractQuantityFromMessage(message) {
    const lowerMsg = message.toLowerCase().trim();
    
    // Pattern: "100 ctns", "50 cartons", "25 ctn"
    const cartonMatch = lowerMsg.match(/(\d+)\s*(?:cartons?|ctns?)/i);
    if (cartonMatch) {
        return parseInt(cartonMatch[1]);
    }
    
    // Pattern: "i need 100", "ordering 50"
    const quantityMatch = lowerMsg.match(/(?:need|want|ordering|order)\s+(\d+)/i);
    if (quantityMatch) {
        return parseInt(quantityMatch[1]);
    }
    
    return null;
}

/**
 * Detect discount negotiation requests
 * IMPORTANT: Should NOT trigger when asking for price of a NEW product
 */
function isDiscountNegotiation(message) {
    const lowerMsg = message.toLowerCase().trim();
    
    // First check if message explicitly asks for discount
    const explicitDiscountPatterns = [
        /give\s*(?:me|us)?\s*(?:some|a)?\s*discount/i,
        /can\s*(?:you|i)\s*get\s*(?:a|some)?\s*discount/i,
        /discount\s*(?:do|mile?ga|chahiye|please|for)/i,
    ];
    
    const hasExplicitDiscount = explicitDiscountPatterns.some(pattern => pattern.test(lowerMsg));
    
    // If message contains product codes (like "8x80", "10*100", "10x100"), it's a PRICE INQUIRY, 
    // UNLESS it explicitly asks for discount
    const hasProductCode = /\d+[x*]\d+/i.test(message);
    if (hasProductCode && !hasExplicitDiscount) {
        return false; // This is a price inquiry for a specific product
    }
    
    const patterns = [
        /^discount\??$/i, // Just "discount" or "discount?"
        /give\s*(?:me|us)?\s*(?:some|a)?\s*discount/i,
        /can\s*(?:you|i)\s*get\s*(?:a|some)?\s*discount/i,
        /discount\s*(?:do|mile?ga|chahiye|please|for)/i,
        /reduce\s*(?:the)?\s*price/i,
        /lower\s*(?:the)?\s*price/i,
        /best\s*price/i,
        /final\s*price/i,
        /final\s*discount/i, // "final discount"
        /kya\s*rate\s*hai/i, // What's your rate
        /last\s*price/i,
        /discount\s*kitna/i, // How much discount
        /kam\s*karo/i, // Reduce it
        /^(?:give\s*me\s*)?more$/i, // "more" or "give me more" (contextual)
        /(?:i\s*)?(?:want|need)\s*(?:some\s*)?more(?:\s*discount)?/i, // "i want more", "i need more", "want some more discount"
        /(?:give|can you give)\s*(?:me\s*)?(?:some\s*)?more(?:\s*discount)?/i, // "give me more", "give some more discount"
        /^(?:aur|zyada)$/i, // Hindi: more
        /(?:give|make|can you do|do)\s*(?:me|it|for)?\s*(?:at|for|@)?\s*(?:‚Çπ|rs\.?)?\s*\d+(?:\.\d+)?/i, // "give me for 2.90", "make it ‚Çπ2.90"
        /\d+(?:\.\d+)?\s*(?:‚Çπ|rs\.?|rupees?)/i, // "2.90 rupees"
    ];
    
    return patterns.some(pattern => pattern.test(lowerMsg));
}

/**
 * Detect specific discount/price requests
 */
function extractDiscountRequest(message) {
    const lowerMsg = message.toLowerCase().trim();
    
    // Check for "more" in discount context (asking for better discount)
    if (/^(?:give\s*me\s*)?more$/i.test(lowerMsg) || 
        /^(?:can\s*(?:i|you)\s*get\s*)?more\??$/i.test(lowerMsg) ||
        /(?:i\s*)?(?:want|need)\s*(?:some\s*)?more(?:\s*discount)?/i.test(lowerMsg) ||
        /(?:give|can you give)\s*(?:me\s*)?(?:some\s*)?more(?:\s*discount)?/i.test(lowerMsg) ||
        /^(?:aur|zyada)$/i.test(lowerMsg)) {
        return {
            type: 'more_discount',
            value: null // Will be handled as asking for better discount
        };
    }
    
    // Check for percentage discount: "give 5% discount", "5 percent off"
    const percentMatch = lowerMsg.match(/(\d+)\s*(?:%|percent|percentage)/i);
    if (percentMatch) {
        return {
            type: 'percentage',
            value: parseFloat(percentMatch[1])
        };
    }
    
    // Check for specific price: "make it ‚Çπ1.45", "give me for 2.90", "1.45 rupees per piece"
    let priceMatch = lowerMsg.match(/(?:‚Çπ|rs\.?|rupees?)\s*(\d+(?:\.\d+)?)/i) || 
                     lowerMsg.match(/(\d+(?:\.\d+)?)\s*(?:‚Çπ|rs\.?|rupees?)/i);
    
    // Also check for "give me for X.XX", "make it X.XX" patterns
    if (!priceMatch) {
        priceMatch = lowerMsg.match(/(?:give|make|can you do|do)\s*(?:me|it|for)?\s*(?:at|for|@)?\s*(\d+(?:\.\d+)?)/i);
    }
    
    if (priceMatch) {
        return {
            type: 'specific_price',
            value: parseFloat(priceMatch[1])
        };
    }
    
    // Check for amount off: "‚Çπ100 off", "200 rupees discount"
    const amountMatch = lowerMsg.match(/(?:‚Çπ|rs\.?|rupees?)\s*(\d+)\s*(?:off|discount|kam)/i);
    if (amountMatch) {
        return {
            type: 'amount_off',
            value: parseFloat(amountMatch[1])
        };
    }
    
    return null;
}

/**
 * Calculate if a discount request is acceptable
 */
function evaluateDiscountRequest(request, currentPrice, quantity, isReturningCustomer) {
    // Get volume discount slab
    const slab = getDiscountSlab(quantity);
    
    if (request.type === 'percentage') {
        const requestedPercent = request.value;
        
        // For returning customers with personalized pricing, be more conservative
        if (isReturningCustomer) {
            // Max 1-2% additional discount for returning customers
            if (requestedPercent <= 2) {
                return {
                    acceptable: true,
                    reason: 'within_returning_customer_limit',
                    counterOffer: requestedPercent
                };
            } else {
                return {
                    acceptable: false,
                    reason: 'exceeds_returning_customer_limit',
                    counterOffer: 1.5 // Offer 1.5% as counter
                };
            }
        }
        
        // For new customers, check against volume discount slab
        if (requestedPercent <= slab.maxDiscount) {
            return {
                acceptable: true,
                reason: 'within_volume_discount_slab',
                counterOffer: requestedPercent
            };
        } else if (requestedPercent <= slab.maxDiscount + 1) {
            // Close to max, can offer max
            return {
                acceptable: 'negotiate',
                reason: 'close_to_max',
                counterOffer: slab.maxDiscount
            };
        } else {
            return {
                acceptable: false,
                reason: 'exceeds_volume_discount',
                counterOffer: slab.maxDiscount
            };
        }
    }
    
    if (request.type === 'specific_price') {
        const requestedPrice = request.value;
        const discountPercent = ((currentPrice - requestedPrice) / currentPrice) * 100;
        
        // Recursively evaluate as percentage
        return evaluateDiscountRequest(
            { type: 'percentage', value: discountPercent },
            currentPrice,
            quantity,
            isReturningCustomer
        );
    }
    
    if (request.type === 'amount_off') {
        const amountOff = request.value;
        const totalAmount = currentPrice * quantity;
        const discountPercent = (amountOff / totalAmount) * 100;
        
        return evaluateDiscountRequest(
            { type: 'percentage', value: discountPercent },
            currentPrice,
            quantity,
            isReturningCustomer
        );
    }
    
    return { acceptable: false, reason: 'unknown_request', counterOffer: 0 };
}

/**
 * Generate smart response for discount negotiation
 */
async function handleDiscountNegotiation(tenantId, phoneNumber, message, conversationContext = null) {
    try {
        console.log('[DISCOUNT_NEG] Handling discount negotiation:', message);
        
        // Special handling for "last price" - offer same discount as previous order
        const isLastPriceRequest = /(?:give\s*me\s*)?last\s*price/i.test(message);
        if (isLastPriceRequest) {
            console.log('[DISCOUNT_NEG] Customer asking for last price - checking previous order discount');
            
            // Get customer profile
            const { data: customer } = await supabase
                .from('customer_profiles')
                .select('id')
                .eq('tenant_id', tenantId)
                .eq('phone', phoneNumber)
                .single();
            
            if (customer) {
                // Get their last order with discount information
                const { data: lastOrder } = await supabase
                    .from('orders')
                    .select(`
                        id,
                        order_number,
                        subtotal_amount,
                        discount_amount,
                        volume_discount_percent,
                        created_at,
                        order_items(product_id, quantity)
                    `)
                    .eq('customer_profile_id', customer.id)
                    .eq('tenant_id', tenantId)
                    .in('status', ['pending', 'confirmed', 'completed'])
                    .order('created_at', { ascending: false })
                    .limit(1)
                    .single();
                
                if (lastOrder && (lastOrder.discount_amount > 0 || lastOrder.volume_discount_percent > 0)) {
                    // Calculate the discount percentage from last order
                    let lastDiscountPercent = lastOrder.volume_discount_percent || 0;
                    
                    if (!lastDiscountPercent && lastOrder.discount_amount > 0 && lastOrder.subtotal_amount > 0) {
                        lastDiscountPercent = ((lastOrder.discount_amount / lastOrder.subtotal_amount) * 100);
                    }
                    
                    console.log('[DISCOUNT_NEG] Found last order discount:', lastDiscountPercent + '%');
                    
                    // Check if there are quoted products in context
                    const { data: recentConv } = await supabase
                        .from('conversations')
                        .select('last_quoted_products')
                        .eq('tenant_id', tenantId)
                        .eq('end_user_phone', phoneNumber)
                        .order('last_message_at', { ascending: false })
                        .limit(1)
                        .single();
                    
                    let products = [];
                    if (recentConv?.last_quoted_products) {
                        try {
                            const quotedProducts = typeof recentConv.last_quoted_products === 'string'
                                ? JSON.parse(recentConv.last_quoted_products)
                                : recentConv.last_quoted_products;

                            // If lastOrder exists, try to use last purchase price for each quoted product
                            if (lastOrder && Array.isArray(lastOrder.order_items)) {
                                products = quotedProducts.map(qp => {
                                    // Find matching product in last order
                                    const lastOrderItem = lastOrder.order_items.find(item => item.product_id === qp.productId || item.product_id === qp.productCode);
                                    let usePrice = qp.price;
                                    if (lastOrderItem && lastOrderItem.price) {
                                        usePrice = lastOrderItem.price;
                                    }
                                    return {
                                        productCode: qp.productCode,
                                        productName: qp.productName,
                                        price: usePrice,
                                        quantity: qp.quantity,
                                        unitsPerCarton: qp.unitsPerCarton || 1500
                                    };
                                });
                            } else {
                                products = quotedProducts.map(p => ({
                                    productCode: p.productCode,
                                    productName: p.productName,
                                    price: p.price,
                                    quantity: p.quantity,
                                    unitsPerCarton: p.unitsPerCarton || 1500
                                }));
                            }
                        } catch (e) {
                            console.warn('[DISCOUNT_NEG] Error parsing quoted products:', e.message);
                        }
                    }
                    
                    // Format the discount offer with product breakdown
                    const roundedDiscount = Math.round(lastDiscountPercent * 10) / 10;
                    let response = `Great! Last time you got ${roundedDiscount}% discount. I can offer you the same deal! üòä\n\n`;
                    
                    if (products.length > 0) {
                        // Show discounted prices for each product
                        response += `With ${roundedDiscount}% discount:\n`;
                        
                        for (const product of products) {
                            const originalPricePerPc = (product.price / product.unitsPerCarton).toFixed(2);
                            const discountedCartonPrice = product.price * (1 - roundedDiscount / 100);
                            const discountedPricePerPc = (discountedCartonPrice / product.unitsPerCarton).toFixed(2);
                            
                            response += `${product.productCode}: ‚Çπ${discountedPricePerPc}/pc (was ‚Çπ${originalPricePerPc}/pc)\n`;
                        }
                        
                        response += `\nShall I apply this ${roundedDiscount}% discount to your order?`;
                    } else {
                        response += `Shall I apply ${roundedDiscount}% discount to your current order?`;
                    }
                    
                    return {
                        response,
                        needsFollowup: true,
                        offeredDiscount: roundedDiscount,
                        approved: false
                    };
                } else {
                    console.log('[DISCOUNT_NEG] Last order had no discount, continuing to regular flow');
                }
            }
        }
        
        // Check if there's a specific discount request
        const request = extractDiscountRequest(message);
        
        // Get conversation context (last quoted products, cart, etc.)
        let cartTotal = 0;
        let totalCartons = 0;
        let isReturningCustomer = false;
        let averagePrice = 0;
        let averageUnitsPerCarton = 0;
        let products = [];
        
        console.log('[DISCOUNT_NEG] ========== INITIAL CONTEXT ==========');
        console.log('[DISCOUNT_NEG] conversationContext:', JSON.stringify(conversationContext, null, 2));
        
        if (conversationContext) {
            cartTotal = conversationContext.cartTotal || 0;
            totalCartons = conversationContext.totalCartons || 0;
            isReturningCustomer = conversationContext.isReturningCustomer || false;
            averagePrice = conversationContext.averagePrice || 0;
            averageUnitsPerCarton = conversationContext.averageUnitsPerCarton || 0;
            products = conversationContext.products || [];
            
            console.log('[DISCOUNT_NEG] Initial values from conversationContext:', {
                cartTotal,
                totalCartons,
                isReturningCustomer,
                averagePrice,
                productsCount: products.length
            });
        }
        
        // üÜï CRITICAL: Check if customer has previous orders to determine returning customer status
        // This is needed because conversationContext might not have this information
        const { data: previousOrders } = await supabase
            .from('orders')
            .select('id')
            .eq('tenant_id', tenantId)
            .eq('customer_phone', phoneNumber)
            .limit(1);
        
        if (previousOrders && previousOrders.length > 0) {
            isReturningCustomer = true;
            console.log('[DISCOUNT_NEG] ‚úÖ Detected returning customer with previous orders');
        }
        
        // üÜï CRITICAL FIX: ONLY check last_quoted_products if NO conversationContext was provided
        // If conversationContext has products array, it means customerHandler already enriched it with personalized pricing
        // DON'T override that enriched data!
        console.log('[DISCOUNT_NEG] ========== CHECKING CONTEXT SOURCE ==========');
        console.log('[DISCOUNT_NEG] Has conversationContext products?', !!(conversationContext?.products?.length));
        
        if (!conversationContext || !conversationContext.products || conversationContext.products.length === 0) {
            console.log('[DISCOUNT_NEG] No enriched products in context, checking last_quoted_products from DB');
            
            const { data: recentConversation } = await supabase
                .from('conversations')
                .select('context_data, last_message_at, last_quoted_products, state')
                .eq('tenant_id', tenantId)
                .eq('end_user_phone', phoneNumber)
                .order('last_message_at', { ascending: false })
                .limit(1)
                .single();
            
            if (recentConversation && recentConversation.last_quoted_products) {
                try {
                    const quotedProducts = typeof recentConversation.last_quoted_products === 'string' 
                        ? JSON.parse(recentConversation.last_quoted_products)
                        : recentConversation.last_quoted_products;
                    
                    const timeSinceQuote = new Date() - new Date(recentConversation.last_message_at);
                    const minutesSinceQuote = timeSinceQuote / (1000 * 60);
                    
                    console.log('[DISCOUNT_NEG] ========== QUOTED PRODUCTS FOUND ==========');
                    console.log('[DISCOUNT_NEG] Time since quote:', minutesSinceQuote.toFixed(1), 'minutes');
                    console.log('[DISCOUNT_NEG] Conversation state:', recentConversation.state);
                    console.log('[DISCOUNT_NEG] Raw quotedProducts:', JSON.stringify(quotedProducts, null, 2));
                    
                    // üÜï EXTENDED: Use quoted products if within 24 hours (1440 minutes)
                    // This allows customers to get price quotes and come back later for discount negotiation
                    if (minutesSinceQuote < 1440 && quotedProducts && quotedProducts.length > 0) {
                        console.log('[DISCOUNT_NEG] ‚úÖ Using quoted products (within 24-hour window)');
                        
                        // Log each product's quantity
                        quotedProducts.forEach((p, idx) => {
                            console.log(`[DISCOUNT_NEG] Product ${idx + 1}:`, {
                                code: p.productCode,
                                name: p.productName,
                                quantity: p.quantity,
                                quantityType: typeof p.quantity
                            });
                        });
                        
                        // OVERRIDE cart data with quoted products data
                        totalCartons = quotedProducts.reduce((sum, p) => sum + (p.quantity || 0), 0);
                        console.log('[DISCOUNT_NEG] ‚úÖ Calculated totalCartons from quotes:', totalCartons);
                        
                        // Map to products array format
                        products = quotedProducts.map(p => ({
                            productCode: p.productCode,
                            productName: p.productName,
                            price: p.price,
                            quantity: p.quantity,
                            unitsPerCarton: p.unitsPerCarton || 1500
                        }));
                        
                        // Calculate average price and cart total
                        if (products.length > 0) {
                            const totalPrice = products.reduce((sum, p) => sum + (p.price || 0), 0);
                            averagePrice = totalPrice / products.length;
                            averageUnitsPerCarton = products[0]?.unitsPerCarton || 1500;
                            cartTotal = products.reduce((sum, p) => sum + (p.price * p.quantity), 0);
                        }
                        
                        console.log('[DISCOUNT_NEG] ‚úÖ Updated context from quoted products:', {
                            totalCartons,
                            cartTotal,
                            productsCount: products.length,
                            quantities: products.map(p => `${p.productCode}:${p.quantity}`)
                        });
                    } else {
                        console.log('[DISCOUNT_NEG] ‚ö†Ô∏è Quoted products too old or empty:', {
                            minutesSinceQuote: minutesSinceQuote.toFixed(1),
                            hasQuotedProducts: !!quotedProducts,
                            quotedProductsLength: quotedProducts?.length || 0
                        });
                    }
                } catch (e) {
                    console.warn('[DISCOUNT_NEG] Failed to parse last_quoted_products:', e.message);
                }
            } else {
                console.log('[DISCOUNT_NEG] No last_quoted_products found in conversation');
            }
        } else {
            console.log('[DISCOUNT_NEG] ‚úÖ Using enriched products from conversationContext (with personalized pricing)');
            console.log('[DISCOUNT_NEG] Products in context:', products.map(p => `${p.productName}: ‚Çπ${p.price}`));
        }
        
        // Calculate per-piece price from carton price
        const calculatePriceWithDiscount = (cartonPrice, discountPercent, unitsPerCarton) => {
            if (!cartonPrice || cartonPrice === 0) return null;
            const discountedCartonPrice = cartonPrice * (1 - discountPercent / 100);
            
            // If we have units per carton, calculate per-piece price
            if (unitsPerCarton && unitsPerCarton > 0) {
                const pricePerPiece = discountedCartonPrice / unitsPerCarton;
                return {
                    perPiece: pricePerPiece.toFixed(2),
                    perCarton: discountedCartonPrice.toFixed(2)
                };
            }
            
            // Otherwise return carton price only
            return {
                perPiece: null,
                perCarton: discountedCartonPrice.toFixed(2)
            };
        };
        
        // Helper to format product discount breakdown
        const formatProductDiscounts = (products, discountPercent) => {
            if (!products || products.length === 0) return null;
            
            // Single product - simple format
            if (products.length === 1) {
                const product = products[0];
                const prices = calculatePriceWithDiscount(product.price, discountPercent, product.unitsPerCarton);
                if (prices && prices.perPiece) {
                    return `‚Çπ${prices.perPiece}/pc`;
                }
                return null;
            }
            
            // Multiple products - show breakdown
            const breakdown = products.map(product => {
                const prices = calculatePriceWithDiscount(product.price, discountPercent, product.unitsPerCarton);
                if (prices && prices.perPiece) {
                    const originalPrice = (product.price / product.unitsPerCarton).toFixed(2);
                    return `${product.productCode}: ‚Çπ${prices.perPiece}/pc (was ‚Çπ${originalPrice}/pc)`;
                }
                return null;
            }).filter(Boolean);
            
            return breakdown.length > 0 ? '\n' + breakdown.join('\n') : null;
        };
        
        let response = ""; // Declare response at the top to avoid hoisting issues
        
        // CRITICAL: Check if totalCartons is still 0 after checking last_quoted_products
        if (totalCartons <= 0) {
            console.log('[DISCOUNT_NEG] No cart and no quoted products - checking for recent order');
            
            // Check if there's a recent order (within last 10 minutes)
            const { data: recentOrder } = await supabase
                .from('orders')
                .select('id, order_number, created_at')
                .eq('tenant_id', tenantId)
                .eq('customer_phone', phoneNumber)
                .order('created_at', { ascending: false })
                .limit(1)
                .single();
            
            if (recentOrder) {
                const orderTime = new Date(recentOrder.created_at);
                const now = new Date();
                const minutesSinceOrder = (now - orderTime) / (1000 * 60);
                
                if (minutesSinceOrder < 10) { // Order placed within last 10 minutes
                    console.log('[DISCOUNT_NEG] Recent order found - denying post-order discount');
                    return {
                        response: "I understand you'd like a discount, but your order has already been created and sent to our system! üòä\n\n" +
                                 "For any changes or special requests on placed orders, please contact our support team directly.\n\n" +
                                 "For your next order, feel free to discuss discounts BEFORE checkout! üôè",
                        needsFollowup: false,
                        offeredDiscount: null,
                        approved: false,
                        postOrderRequest: true
                    };
                }
            }
            
            // No recent order - general discount inquiry
            console.log('[DISCOUNT_NEG] ========== FINAL CHECK BEFORE GENERIC RESPONSE ==========');
            console.log('[DISCOUNT_NEG] Final totalCartons value:', totalCartons);
            console.log('[DISCOUNT_NEG] Final products array:', products);
            console.log('[DISCOUNT_NEG] Final cartTotal:', cartTotal);
            console.log('[DISCOUNT_NEG] About to return generic discount inquiry response');
            
            return {
                response: "I'd love to help with a discount! üòä\n\nHow many cartons are you looking to order? Discounts vary based on quantity:\n\nüì¶ 11-25 cartons ‚Üí 2-3% off\nüì¶ 26-50 cartons ‚Üí 4-5% off\nüì¶ 51+ cartons ‚Üí 6%+ off",
                needsFollowup: true,
                offeredDiscount: null,
                approved: false
            };
        }
        
        console.log('[DISCOUNT_NEG] ========== PROCEEDING WITH DISCOUNT CALCULATION ==========');
        console.log('[DISCOUNT_NEG] Final totalCartons for calculation:', totalCartons);
        console.log('[DISCOUNT_NEG] Final products count:', products.length);
        console.log('[DISCOUNT_NEG] Final cartTotal:', cartTotal);
        
        // REMOVED: Legacy check that incorrectly treated 10 cartons as "no quantity"
        // Customers can legitimately want 10 cartons, so we handle it properly below
        
        // If no specific request, offer FIRST discount (2% or min of slab)
        if (!request) {
            
            if (isReturningCustomer) {
                // For returning customers, offer small additional discount
                const discountOffer = 1.5;
                const productBreakdown = formatProductDiscounts(products, discountOffer);
                
                if (productBreakdown) {
                    response = `You're already on special pricing! üòä\n\nBut I can give you an extra ${discountOffer}% off:${productBreakdown}\n\nSound good?`;
                } else {
                    response = `You're already on special pricing! üòä\n\nI can offer you an additional ${discountOffer}% discount on this order. Shall I apply that?`;
                }
            } else if (totalCartons > 0) {
                const slab = getDiscountSlab(totalCartons);
                // Offer MINIMUM discount first (be conservative)
                const initialOffer = slab.minDiscount || 2;
                const productBreakdown = formatProductDiscounts(products, initialOffer);
                
                if (productBreakdown) {
                    response = `I can offer you ${initialOffer}% discount:${productBreakdown}\n\nDoes that work for you?`;
                } else {
                    // Fallback to average price if product breakdown not available
                    const prices = calculatePriceWithDiscount(averagePrice, initialOffer, averageUnitsPerCarton);
                    if (prices && prices.perPiece) {
                        response = `I can offer you ${initialOffer}% discount - that brings it to ‚Çπ${prices.perPiece}/pc üëç\n\nDoes that work for you?`;
                    } else {
                        response = `I can offer you ${initialOffer}% discount for ${totalCartons} cartons.\n\nShall I apply that to your order?`;
                    }
                }
            } else {
                // No context yet - ask for details
                response = "Sure! What products and quantity are you looking at? That way I can give you the exact discounted price üòä";
            }
            
            return {
                response,
                needsFollowup: true,
                offeredDiscount: isReturningCustomer ? 1.5 : (totalCartons > 0 ? getDiscountSlab(totalCartons).minDiscount : 0)
            };
        }
        
        // Handle "give me more" / "more discount" requests
        if (request.type === 'more_discount') {
            const slab = getDiscountSlab(totalCartons);
            // Offer a better discount (mid-range of the slab)
            const betterOffer = Math.ceil((slab.minDiscount + slab.maxDiscount) / 2);
            const productBreakdown = formatProductDiscounts(products, betterOffer);
            
            if (productBreakdown) {
                response = `Okay, let me see what I can do... ${betterOffer}% is the best I can manage:${productBreakdown}\n\nThat's a solid deal! What do you think?`;
            } else {
                const prices = calculatePriceWithDiscount(averagePrice, betterOffer, averageUnitsPerCarton);
                if (prices && prices.perPiece) {
                    response = `Alright, I can stretch to ${betterOffer}% for you - that's ‚Çπ${prices.perPiece}/pc üòä\n\nThat's really the best I can do. Deal?`;
                } else {
                    response = `Okay, I can do ${betterOffer}% discount for ${totalCartons} cartons.\n\nThat's stretching it for me! Sound good?`;
                }
            }
            
            return {
                response,
                approved: false,
                needsFollowup: true,
                offeredDiscount: betterOffer
            };
        }
        
        // Evaluate the specific request
        const evaluation = evaluateDiscountRequest(
            request,
            conversationContext?.averagePrice || 2400, // Default fallback
            totalCartons || 10,
            isReturningCustomer
        );
        
        // response variable already declared at the top
        
        if (evaluation.acceptable === true) {
            // Accept the request - enthusiastic and natural
            const responses = [
                `Done! ‚úÖ\n\n${request.type === 'percentage' ? `${request.value}% discount` : `‚Çπ${request.value} per piece`} works for me.\n\nShall I go ahead and process this?`,
                `Perfect, I can do that! ${request.type === 'percentage' ? `${request.value}% off` : `‚Çπ${request.value}/piece`} üëç\n\nReady to place the order?`,
                `You got it! ${request.type === 'percentage' ? `${request.value}% discount` : `‚Çπ${request.value} rate`} is good.\n\nShall we confirm this order?`
            ];
            response = responses[Math.floor(Math.random() * responses.length)];
            
            return {
                response,
                approved: true,
                discountPercent: evaluation.counterOffer,
                needsFollowup: false
            };
            
        } else if (evaluation.acceptable === 'negotiate') {
            // Close to max, offer MAX discount with calculated price
            const slab = getDiscountSlab(totalCartons);
            const maxDiscount = slab.maxDiscount || 3;
            const productBreakdown = formatProductDiscounts(products, maxDiscount);
            
            if (productBreakdown) {
                const responses = [
                    `Alright, let me do ${maxDiscount}% for you:${productBreakdown}\n\nThat's genuinely my maximum. Deal? üëç`,
                    `Okay, I can stretch to ${maxDiscount}%:${productBreakdown}\n\nThat's the best I can offer. Sound good?`,
                    `${maxDiscount}% is my absolute max:${productBreakdown}\n\nShall we go ahead with this?`
                ];
                response = responses[Math.floor(Math.random() * responses.length)];
            } else {
                // Fallback to average price
                const prices = calculatePriceWithDiscount(averagePrice, maxDiscount, averageUnitsPerCarton);
                if (prices && prices.perPiece) {
                    const responses = [
                        `Alright, let me do ${maxDiscount}% for you - that's ‚Çπ${prices.perPiece}/pc\n\nThat's genuinely my maximum. Deal? üëç`,
                        `Okay, I can stretch to ${maxDiscount}% - brings it to ‚Çπ${prices.perPiece}/pc\n\nThat's the best I can offer. Sound good?`,
                        `${maxDiscount}% is my absolute max - ‚Çπ${prices.perPiece}/pc final price.\n\nShall we go ahead with this?`
                    ];
                    response = responses[Math.floor(Math.random() * responses.length)];
                } else {
                    const responses = [
                        `Alright, ${maxDiscount}% is my maximum for ${totalCartons} cartons.\n\nThat's the best I can do. Fair?`,
                        `I can stretch to ${maxDiscount}% - that's my absolute limit.\n\nDoes that work for you?`,
                        `${maxDiscount}% is the most I can offer. That's genuinely my max üëç`
                    ];
                    response = responses[Math.floor(Math.random() * responses.length)];
                }
            }
            
            return {
                response,
                approved: true,
                discountPercent: maxDiscount,
                needsFollowup: false
            };
            
        } else {
            // Cannot accept - they want MORE than max
            // Check if this looks like a follow-up "more discount" request
            const isAskingForMore = /\b(more|aur|zyada|any\s*other|kuch\s*aur|extra)\s*discount/i.test(message);

            if (isAskingForMore) {
                // They're pushing beyond max - escalate to manager
                const responses = [
                    `I've already given you my best rate üòÖ\n\nLet me check with my manager and get back to you. Can I call you in a bit?`,
                    `That's beyond what I can approve myself.\n\nLet me speak to my manager about this - I'll get back to you shortly!`,
                    `I really want to help, but that's above my limit!\n\nGive me some time to check with the team. I'll message you back soon üëç`
                ];
                response = responses[Math.floor(Math.random() * responses.length)];

                return {
                    response,
                    approved: false,
                    needsEscalation: true,
                    needsFollowup: false
                };
            }

            // ‚úÖ CRITICAL FIX: Use counterOffer from evaluation instead of recalculating
            // The evaluation already determined the correct maximum discount based on customer type
            let maxDiscount = evaluation.counterOffer || 0;

            // ‚úÖ FALLBACK: If counterOffer is 0 or missing, calculate from context
            if (maxDiscount === 0) {
                if (isReturningCustomer) {
                    // Returning customers get 1.5% additional on personalized pricing
                    maxDiscount = 1.5;
                    console.log('[DISCOUNT_NEG] Returning customer - offering 1.5% additional');
                } else {
                    // New customers get volume discount slab
                    const slab = getDiscountSlab(totalCartons);
                    maxDiscount = slab.maxDiscount || 2; // Minimum 2% for any customer
                    console.log('[DISCOUNT_NEG] New customer - volume slab:', maxDiscount + '%');
                }
            }

            console.log('[DISCOUNT_NEG] Final maxDiscount for rejection:', {
                maxDiscount,
                isReturningCustomer,
                totalCartons,
                evaluationCounterOffer: evaluation.counterOffer
            });

            const productBreakdown = formatProductDiscounts(products, maxDiscount);

            if (isReturningCustomer) {
                response = `You're already on special pricing! üòä\n\nThe maximum I can add is ${maxDiscount}% extra. That's genuinely my limit.\n\nShall I apply that?`;
            } else if (productBreakdown) {
                response = `For ${totalCartons} cartons, ${maxDiscount}% is my absolute maximum:${productBreakdown}\n\nI can't go any lower than that. Deal?`;
            } else {
                // Fallback to average price
                const prices = calculatePriceWithDiscount(averagePrice, maxDiscount, averageUnitsPerCarton);
                if (prices && prices.perPiece) {
                    response = `For ${totalCartons} cartons, ${maxDiscount}% is my absolute maximum - that's ‚Çπ${prices.perPiece}/pc\n\nI can't go any lower than that. Deal?`;
                } else {
                    response = `For ${totalCartons} cartons, ${maxDiscount}% is my maximum.\n\nThat's the best rate I can offer. Sound good?`;
                }
            }

            return {
                response,
                approved: false,
                counterOffer: maxDiscount,
                needsFollowup: true
            };
        }
        
    } catch (error) {
        console.error('[DISCOUNT_NEG] Error:', error);
        return {
            response: "Let me check what I can offer you. Please share your cart details or the products you want to order.",
            needsFollowup: true,
            error: error.message
        };
    }
}

/**
 * Handle "give me your best price" / "final price" requests
 */
async function handleBestPriceRequest(tenantId, phoneNumber, conversationContext) {
    try {
        const totalCartons = conversationContext?.totalCartons || 0;
        const isReturningCustomer = conversationContext?.isReturningCustomer || false;
        
        let response = "";
        
        if (isReturningCustomer) {
            // Natural, appreciative response for loyal customers
            const responses = [
                `Alright, my absolute best for you:\n\nYou're already on personalized pricing, PLUS I'll throw in an extra 1.5% off this order ÔøΩ\n\nThat's genuinely the best I can do - deal?`,
                `Okay, here's what I can offer:\n\n‚ú® Your personalized rate + 1.5% discount\n‚ú® I'll prioritize your order\n\nThat's my final offer for a valued customer like you! ü§ù`,
                `Let me be straight with you - you're already getting great pricing!\n\nBut I can add 1.5% more off just for you. That's genuinely my max. Sound good?`
            ];
            response = responses[Math.floor(Math.random() * responses.length)];
            
            return {
                response,
                approved: true,
                discountPercent: 1.5,
                needsFollowup: false
            };
        }
        
        // For new customers, offer max discount for their slab
        if (totalCartons > 0) {
            const slab = getDiscountSlab(totalCartons);
            
            const responses = [
                `Alright, straight talk - for ${totalCartons} cartons, I can do ${slab.maxDiscount}% off. That's my max.\n\nFair price, good quality. Deal? üëç`,
                `Here's my best: ${slab.maxDiscount}% discount on ${totalCartons} cartons.\n\nThat's the most I can offer at this quantity. Shall we go ahead?`,
                `Okay, ${totalCartons} cartons - I'll give you ${slab.maxDiscount}% off.\n\nThat's genuinely the best rate I can do. Ready to order?`
            ];
            response = responses[Math.floor(Math.random() * responses.length)];
            
            return {
                response,
                approved: true,
                discountPercent: slab.maxDiscount,
                needsFollowup: false
            };
        }
        
        // No context - ask naturally
        const responses = [
            "I'd love to give you the best price! Just tell me what products and how many cartons - then I can give you my final offer üòä",
            "Sure! What are you looking to order and how much? That way I can work out the absolute best rate for you.",
            "Happy to! Which products and what quantity? Let me know and I'll give you my best pricing ÔøΩ"
        ];
        response = responses[Math.floor(Math.random() * responses.length)];
        
        return {
            response,
            approved: false,
            needsFollowup: true
        };
        
    } catch (error) {
        console.error('[DISCOUNT_NEG] Error in best price:', error);
        return {
            response: "Let me know your requirements and I'll give you my best offer!",
            needsFollowup: true
        };
    }
}

module.exports = {
    isDiscountNegotiation,
    extractDiscountRequest,
    extractQuantityFromMessage,
    evaluateDiscountRequest,
    handleDiscountNegotiation,
    handleBestPriceRequest
};
