const { formatPersonalizedPriceDisplay } = require('../../services/pricingDisplayService');
// === AI INTEGRATION POINTS ===.
const aiHandlerHelper = require('../../services/aiHandlerHelper');
// Main Message Handler
async function handleCustomerMessage(normalizedMessage) {
    const { message, phoneNumber, tenantId } = normalizedMessage;
    try {
        // === NEW: AI ROUTING ===
        const aiRouting = await aiHandlerHelper.processAndRoute(phoneNumber, message, tenantId);
        console.log(`ðŸ¤– AI Routing Decision: ${aiRouting.action}`);
        if (aiRouting.aiResponse) {
            return await sendMessage(phoneNumber, aiRouting.aiResponse);
        }
        if (aiRouting.shouldTransferHuman) {
            return await transferToHuman(phoneNumber, aiRouting.intent);
        }
        // ...existing rule-based logic...
    } catch (error) {
        console.error('Error in customer handler:', error);
        // ...error handling...
    }
}

// Order Flow Integration
async function confirmOrder(customerProfileId, orderItems) {
    try {
        const orderCheck = await aiHandlerHelper.checkOrderAndSuggest(customerProfileId, orderItems);
        if (orderCheck.hasSuggestions) {
            await sendMessage(phoneNumber, orderCheck.message);
            // Wait for customer response...
        }
        // ...existing order confirmation...
    } catch (error) {
        console.error('Error in order flow:', error);
    }
}

// Complex Query Handler
async function handleComplexQuery(phoneNumber, message, tenantId) {
    try {
        const aiResponse = await aiHandlerHelper.forceAIResponse(phoneNumber, message, tenantId, { useSmartModel: true });
        if (aiResponse) {
            return await sendMessage(phoneNumber, aiResponse);
        }
        return await sendMessage(phoneNumber, 'I\'m not sure about that. Let me connect you with our team.');
    } catch (error) {
        console.error('Error handling complex query:', error);
    }
}

const aiIntegration = require('../../services/aiIntegrationService');
const { viewCartWithDiscounts, checkoutWithDiscounts } = require('../../services/cartService');
const { applyApprovedDiscountToCart } = require('../../services/cartService');
const { processOrderRequestEnhanced, processMultipleOrderRequest } = require('../../services/orderProcessingService');
const { extractOrderDetails } = require('../../services/smartOrderExtractionService');
const { autoAddDiscussedProductToCart } = require('../../services/orderConfirmationService');
const { recognizeIntent } = require('../../services/intentRecognitionService');
const { analyzeConversationContext } = require('../../services/aiConversationContextService');
const { 
    isDiscountNegotiation, 
    extractQuantityFromMessage,
    handleDiscountNegotiation, 
    handleBestPriceRequest 
} = require('../../services/discountNegotiationService');
/**
 * Safely parse context_data (handles both string and object)
 */
function safeParseContextData(contextData) {
    if (!contextData) return {};
    
    // Already an object
    if (typeof contextData === 'object' && contextData !== null) {
        return contextData;
    }
    
    // String - needs parsing
    if (typeof contextData === 'string') {
        try {
            return JSON.parse(contextData);
        } catch (e) {
            console.error('[CONTEXT_PARSE] Invalid JSON:', e.message);
            return {};
        }
    }
    
    // Unknown type
    return {};
}
/**
 * Enhanced order confirmation detection
 */
const isOrderConfirmationEnhanced = async (userQuery, conversation, tenantId) => {
    const cleanQuery = userQuery.toLowerCase().trim();
    
    // CRITICAL: If message contains quantity specification, it's NOT a confirmation
    // Examples: "i need 100 cartons", "i want 50", "make it 25 cartons"
    const hasQuantitySpecification = /(?:i\s*)?(?:need|want|make\s*it|give\s*me)\s+\d+\s*(?:cartons?|ctns?|pcs?|pieces?)/i.test(cleanQuery);
    if (hasQuantitySpecification) {
        console.log('[ORDER_CONFIRM] Rejected - message contains quantity specification:', cleanQuery);
        return false;
    }
    
    // NEW FIX: Reject if "add" with product code (different from last discussed)
    const productCodePattern = /\b\d+[x*]\d+\b/i;
    const messageProductCode = userQuery.match(productCodePattern)?.[0]?.toLowerCase();
    const lastDiscussedCode = conversation?.last_product_discussed?.match(productCodePattern)?.[0]?.toLowerCase();
    
    if (messageProductCode && lastDiscussedCode && messageProductCode !== lastDiscussedCode) {
        console.log('[ORDER_CONFIRM] Rejected - different product code detected');
        console.log(`[ORDER_CONFIRM] Last discussed: ${lastDiscussedCode}, New: ${messageProductCode}`);
        return false;
    }
    
    // NEW FIX: "add PRODUCTCODE" should be treated as new order, not confirmation
    const hasAddWithProduct = /(?:add|dd)\s+\d+[x*]\d+/i.test(userQuery);
    if (hasAddWithProduct) {
        console.log('[ORDER_CONFIRM] Rejected - "add" with product code is a new order');
        return false;
    }
    
    // Basic confirmation patterns
    const confirmationPatterns = [
        /^yes$/i,
        /^yes\s+(confirm|go ahead|please|ok|sure)$/i,
        /^(confirm|proceed|place|order)\s*(it|order|this)?$/i,
        /^go ahead$/i,
        /^confirm$/i,
        /^proceed$/i,
        /^ok$/i,
        /^okay$/i,
        /^sure$/i,
        /^yes please$/i,
        /^haan$/i,
        /^theek hai$/i,
        /^kar do$/i,
        /^place order$/i,
        /^checkout$/i,
    ];
    // Check basic patterns
    const matchesPattern = confirmationPatterns.some(pattern => pattern.test(cleanQuery));
    if (!matchesPattern) {
        return false;
    }
    // Check if there's a cart or quoted products
    if (!conversation) {
        return false;
    }
    // Check for cart
    const { data: cart } = await supabase
        .from('carts')
        .select('id, cart_items(id)')
        .eq('conversation_id', conversation.id)
        .single();
    const hasCartItems = cart && cart.cart_items && cart.cart_items.length > 0;
    // Check for quoted products
    const hasQuotedProducts = conversation.last_quoted_products || conversation.last_product_discussed;
    return matchesPattern && (hasCartItems || hasQuotedProducts);
};

const { 
    handleInvoiceRequest, 
    handleOrderApproval, 
    handleZohoStatusCommand 
} = require('./zohoOperationsHandler');
const { sendMessage, sendMessageWithImage } = require('../../services/whatsappService');
const { logMessage, getConversationHistory, getConversationId } = require('../../services/historyService');
const { getAIResponse, getAIResponseV2 } = require('../../services/aiService');
const { categorizeResponse, updateConversationCategory } = require('../../services/followUpService');
const { isWithinOfficeHours } = require('../../services/officeHoursService');
const { supabase } = require('../../services/config');
const { getCustomerProfile } = require('../../services/customerProfileService');
const { checkOnboardingStatus, startOnboarding, handleOnboardingFlow } = require('../../services/customerOnboardingService');
const debug = require('../../services/debug');
const { processFollowUpResponse } = require('../../services/enhancedFollowUpService');
const { detectLanguage, translateMessage } = require('../../services/multiLanguageService');
// === FOLLOW-UP SCHEDULING ===
const { handleFollowUpRequest } = require('../../services/followUpSchedulerService');
const { handleShipmentTracking } = require('../../handlers/shipmentTrackingHandler');
const { trackCustomerMessage, trackBotMessage } = require('../../services/realtimeTestingService');
const { findQuickReplyResponse } = require('../../services/quickReplyService');
const { findFaqResponse } = require('../../services/faqService');
const { findKeywordResponse } = require('../../services/keywordService');
const { getProductRecommendations } = require('../../services/recommendationService');
const { isHandoverRequest, flagAndNotifyForHandover } = require('../../services/handoverService');
const { detectHandoverTriggers } = require('../../services/humanHandoverService');
const { scoreLead } = require('../../services/leadScoringService');
const { unsubscribeUser } = require('../../services/dripCampaignService');
const menuService = require('../../services/menuService');
const segmentationService = require('../../services/segmentationService');
const followUpSuggestionService = require('../../services/followUpSuggestionService');
const { getSmartResponse } = require('../../services/smartResponseRouter');
const { trackResponse } = require('../../services/responseAnalytics');
const { detectQuantityChange, updateCartQuantity } = require('../../services/quantityChangeService');



const {
    applyDiscount,
    removeDiscount,
    getAutomaticDiscounts
} = require('../../services/discountService');

const {
    addCartonProductToCart,
    viewCartonCart
} = require('../../services/cartonPricingService');

const {
    findProductOrVariant,
    findProductByNameOrCode,
    calculatePackagingPricing,
    formatProductDisplay,
    searchProductsAndVariants
} = require('../../services/enhancedProductService');
const { convertSalesOrderToInvoice, generateInvoicePDF } = require('../../services/zohoInvoiceService');

// === ENHANCED MULTI-PRODUCT HANDLER (NEW ADDITION) ===
/**
 * Enhanced multi-product order detection for combined messages
 * Handles patterns like "8x80 - 36 ctns and 8x100 - 4 ctns"
 * FIXED: Uses supabase import directly instead of relying on enhancedProductService
 */
const extractCombinedOrderDetails = async (userQuery, tenantId) => {
    try {
        // [LOG] Processing combined order query
        
        // Clean the query - remove greetings
        const cleanQuery = userQuery
            .trim()
            .replace(/^(hello|hey|hi|dear|i\s+need|i\s+want|mujhe)\s*/i, '')
            .replace(/\s+/g, ' ')
            .trim();

    // [LOG] Cleaned combined order query

        // Enhanced patterns for combined product+quantity messages
        const combinedPatterns = [
            // "8x80 - 36 ctns and 8x100 - 4 ctns"
            /(\d+[x*]\d+)\s*-\s*(\d+)\s*c(?:artons?|tns?)\s*(?:and|&|,)\s*(\d+[x*]\d+)\s*-\s*(\d+)\s*c(?:artons?|tns?)/gi,
            
            // "8x80: 36 ctns, 8x100: 4 ctns"  
            /(\d+[x*]\d+)\s*[:]\s*(\d+)\s*c(?:artons?|tns?)\s*[,]\s*(\d+[x*]\d+)\s*[:]\s*(\d+)\s*c(?:artons?|tns?)/gi,
            
            // "NFF 8x80 - 36 ctns and NFF 8x100 - 4 ctns"
            /(?:nff\s*)?(\d+[x*]\d+)\s*-\s*(\d+)\s*c(?:artons?|tns?)\s*(?:and|&|,)\s*(?:nff\s*)?(\d+[x*]\d+)\s*-\s*(\d+)\s*c(?:artons?|tns?)/gi
        ];

        let extractedProducts = [];

        // Internal product lookup function (bypassing enhancedProductService)
        const findProductByCode = async (tenantId, productCode) => {
            try {
                // Try exact and common variants
                const searchVariants = [
                    productCode,
                    `NFF ${productCode}`,
                    `NFF-${productCode}`
                ];
                for (const term of searchVariants) {
                    const { data: exactProducts } = await supabase
                        .from('products')
                        .select('*')
                        .eq('tenant_id', tenantId)
                        .eq('is_active', true)
                        .eq('name', term)
                        .limit(1);
                    if (exactProducts && exactProducts.length > 0) {
                        return exactProducts[0];
                    }
                }
                // Try pattern/partial matches (accept if code is at end or after space/hyphen)
                const { data: patternProducts } = await supabase
                    .from('products')
                    .select('*')
                    .eq('tenant_id', tenantId)
                    .eq('is_active', true)
                    .ilike('name', `%${productCode}`)
                    .neq('price', 0)
                    .order('name');
                if (patternProducts && patternProducts.length > 0) {
                    // Accept if code is at end, after space, or after hyphen
                    const filtered = patternProducts.filter(product => {
                        const name = product.name.toLowerCase();
                        const code = productCode.toLowerCase();
                        if (name.endsWith(code)) return true;
                        if (name.replace(/[- ]/g, '').endsWith(code.replace(/[- ]/g, ''))) return true;
                        return false;
                    });
                    if (filtered.length > 0) {
                        return filtered[0];
                    }
                }
                // Fallback: any partial match
                const { data: looseProducts } = await supabase
                    .from('products')
                    .select('*')
                    .eq('tenant_id', tenantId)
                    .eq('is_active', true)
                    .ilike('name', `%${productCode}%`)
                    .neq('price', 0)
                    .order('name');
                if (looseProducts && looseProducts.length > 0) {
                    return looseProducts[0];
                }
                console.warn('[ORDER] Product not found', { productCode, tenantId });
                return null;
            } catch (error) {
                console.error('[ORDER] Product search error', { error: error.message, productCode, tenantId });
                return null;
            }
        };

        // Check each pattern
        for (const pattern of combinedPatterns) {
            const matches = [...cleanQuery.matchAll(pattern)];
            
            if (matches.length > 0) {
                // [LOG] Combined order pattern matched
                
                for (const match of matches) {
                    // Extract both products from the match
                    const product1Code = match[1].replace('*', 'x');
                    const product1Qty = parseInt(match[2]);
                    const product2Code = match[3].replace('*', 'x');
                    const product2Qty = parseInt(match[4]);
                    
                    // [LOG] Extracted product codes and quantities from combined order
                    
                    // Validate and add products
                    if (product1Code && product1Qty > 0) {
                        const product1 = await findProductByCode(tenantId, product1Code);
                        if (product1) {
                            extractedProducts.push({
                                productName: product1.name || `NFF ${product1Code}`,
                                productCode: product1Code,
                                quantity: product1Qty,
                                unit: 'carton',
                                originalText: `${product1Code} - ${product1Qty} ctns`
                            });
                        } else {
                            console.warn('[ORDER] Product not found', { productCode: product1Code, tenantId });
                        }
                    }
                    
                    if (product2Code && product2Qty > 0) {
                        const product2 = await findProductByCode(tenantId, product2Code);
                        if (product2) {
                            extractedProducts.push({
                                productName: product2.name || `NFF ${product2Code}`,
                                productCode: product2Code,
                                quantity: product2Qty,
                                unit: 'carton',
                                originalText: `${product2Code} - ${product2Qty} ctns`
                            });
                        } else {
                            console.warn('[ORDER] Product not found', { productCode: product2Code, tenantId });
                        }
                    }
                }
                // Found a pattern, continue checking for more
            }
        }

        // Fallback: Look for multiple individual product+quantity pairs
        if (extractedProducts.length === 0) {
            const individualMatches = [...cleanQuery.matchAll(/(\d+[x*]\d+)\s*[-:]?\s*(\d+)\s*c(?:artons?|tns?)/gi)];
            
            if (individualMatches.length >= 2) {
                // [LOG] Found individual product+quantity pairs in combined order
                
                for (const match of individualMatches) {
                    const productCode = match[1].replace('*', 'x');
                    const quantity = parseInt(match[2]);
                    
                    if (productCode && quantity > 0) {
                        const product = await findProductByCode(tenantId, productCode);
                        if (product) {
                            extractedProducts.push({
                                productName: product.name || `NFF ${productCode}`,
                                productCode: productCode,
                                quantity: quantity,
                                unit: 'carton',
                                originalText: match[0]
                            });
                        }
                    }
                }
            }
        }

        // Remove duplicates and return results
        const uniqueProducts = extractedProducts.filter((product, index, self) => 
            index === self.findIndex(p => p.productCode === product.productCode)
        );

        if (uniqueProducts.length > 0) {
            // [LOG] Successfully extracted products from combined order
            
            return {
                success: true,
                isMultipleProducts: uniqueProducts.length > 1,
                products: uniqueProducts,
                extractionMethod: 'combined_product_quantity',
                originalText: userQuery
            };
        }

    // [LOG] No valid combined order patterns found
        return null;

    } catch (error) {
    console.error('[ORDER] Combined order extraction error', { error });
        return null;
    }
};
// === END ENHANCED MULTI-PRODUCT HANDLER ===

/**
 * Safe wrapper for segmentation service
 */

/**
 * A wrapper for sendMessage that also logs the bot's reply to the history.
 */
const sendAndLogMessage = async (to, text, tenantId, messageType) => {
    await sendMessage(to, text);
    await logMessage(tenantId, to, 'bot', text, messageType);
};

/**
 * Safe keyword lookup wrapper
 */
const findKeywordResponseSafe = async (tenantId, text) => {
    try {
        const keywordResponse = await findKeywordResponse(tenantId, text);
        return keywordResponse;
    } catch (e) {
    console.error('[KEYWORD] findKeywordResponseSafe error', { error: e?.message || e });
        return null;
    }
};

/**
 * Dynamic AI prompt generation based on tenant's product catalog
 */
const createDynamicAIPrompt = async (userQuery, userLanguage, tenantId, conversation) => {
    try {
        // Get tenant configuration
        const { data: tenant } = await supabase
            .from('tenants')
            .select('business_name, bot_personality, bot_language, industry_type')
            .eq('id', tenantId)
            .single();

        // Get product context dynamically
        const { data: products } = await supabase
            .from('products')
            .select('name, description, price, packaging_unit, units_per_carton, technical_details')
            .eq('tenant_id', tenantId)
            .limit(20);

        const productContext = products?.length > 0 ? 
            `Available Products:\n${products.map(p => 
                `- ${p.name}: ${p.description} (â‚¹${p.price}${p.packaging_unit === 'carton' ? '/carton' : ''})${p.units_per_carton ? ` [${p.units_per_carton} pcs/carton]` : ''}`
            ).join('\n')}` : 
            'No products configured yet.';

        // Dynamic language instructions with better Hinglish support
        const languageInstructions = {
            'hi': 'Respond in Hindi (à¤¹à¤¿à¤‚à¤¦à¥€ à¤®à¥‡à¤‚ à¤œà¤µà¤¾à¤¬ à¤¦à¥‡à¤‚)',
            'hinglish': 'Respond in Hinglish (Hindi-English mix). Use words like: hai, hain, kya, aapke paas, chahiye, kar do, thik hai. Mix Hindi and English naturally like the customer.',
            'en': 'Respond in English'
        };

        // Priority: user's detected language over tenant setting for natural conversation
        const selectedLanguage = userLanguage || tenant?.bot_language?.toLowerCase() || 'en';

    // [LOG] Language selected for AI prompt

        // Check if we're in an order discussion
        const isOrderDiscussion = conversation?.state?.includes('order_discussion') || 
                                 conversation?.last_product_discussed;

        const orderContext = isOrderDiscussion ? 
            `\nCURRENT ORDER CONTEXT: Customer is discussing order for "${conversation?.last_product_discussed}". ` +
            `If they confirm or ask for final pricing, they want to CHECKOUT.` : '';

        return `You are a helpful sales assistant for ${tenant?.business_name || 'this business'}${tenant?.industry_type ? ` in the ${tenant.industry_type} industry` : ''}.

${productContext}

INSTRUCTIONS:
1. PRODUCT DETAILS: Answer questions about products using the available information above
2. PRICING: Always provide exact prices from the product list when available
3. ORDER PROCESSING: 
   - Help customers place orders for any quantities
   - For carton products, convert pieces to cartons automatically
   - Calculate totals using available pricing data
4. CONFIRMATION: Recognize order confirmations and help complete purchases

QUANTITY CHANGE HANDLING:
- When customer requests quantity changes (e.g. "make it 7ctns"), provide clear calculations
- Format: "7 cartons = 4900 total pieces (700 per carton)"
- Do NOT use confusing intermediate calculations
- Always update the cart with new quantities

${orderContext}

${tenant?.bot_personality ? `PERSONALITY: ${tenant.bot_personality}` : ''}

Customer message (in ${selectedLanguage}): ${userQuery}

Important: ${languageInstructions[selectedLanguage] || languageInstructions['en']}. 

Help customers complete their purchases efficiently.`;

    } catch (error) {
    console.error('[AI] Error creating dynamic AI prompt', { error: error.message });
        // Fallback to basic prompt
        return `You are a helpful sales assistant. Customer message: ${userQuery}`;
    }
};

/**
 * Handle order confirmation flow using modular services
 */
const handleOrderConfirmation = async (tenant, from, conversation, res) => {
    try {
        // Check if there's something in cart
        const { data: cart } = await supabase
            .from('carts')
            .select(`
                id,
                cart_items (
                    quantity,
                    product:products (name, price)
                )
            `)
            .eq('conversation_id', conversation.id)
            .single();

        if (cart && cart.cart_items && cart.cart_items.length > 0) {
            // Proceed with checkout using modular service
            const result = await checkoutWithDiscounts(tenant, from);
            await sendAndLogMessage(from, result, tenant.id, 'checkout_confirmed');
            
            // Send QR code message if available  
            if (tenant.payment_qr_code_url) {
                try {
                    const qrMessage = "QR code available for payment. Please contact us for the QR code image.";
                    await sendAndLogMessage(from, qrMessage, tenant.id, 'qr_code_available');
                } catch (qrError) {
                    console.error('[ORDER] Failed to send QR code message', { error: qrError.message });
                }
            }
            
            // Clear order discussion state
            await supabase
                .from('conversations')
                .update({ 
                    state: null,
                    last_product_discussed: null
                })
                .eq('id', conversation.id);
                
            return res.status(200).json({ ok: true, type: 'order_confirmed' });
        } else {
            // Auto-add discussed product using modular service
            const autoAddResult = await autoAddDiscussedProductToCart(tenant.id, from, conversation);
            
            if (autoAddResult.success) {
                // Proceed with checkout
                const result = await checkoutWithDiscounts(tenant, from);
                await sendAndLogMessage(from, 
                    `âœ… Added ${autoAddResult.product.name} to cart!\n\n${result}`, 
                    tenant.id, 'emergency_checkout_success');

                // Send QR code message if available  
                if (tenant.payment_qr_code_url) {
                    try {
                        const qrMessage = "QR code available for payment. Please contact us for the QR code image.";
                        await sendAndLogMessage(from, qrMessage, tenant.id, 'qr_code_available');
                    } catch (qrError) {
                        console.error('[ORDER] Failed to send QR code message', { error: qrError.message });
                    }
                }

                return res.status(200).json({ ok: true, type: 'emergency_fix_success' });
            } else {
                // Fallback message if auto-add failed
                await sendAndLogMessage(from, 
                    'Your cart is empty. Add some products before checking out!',
                    tenant.id, 'empty_cart_checkout');
                return res.status(200).json({ ok: true, type: 'empty_cart_checkout' });
            }
        }
    } catch (error) {
    console.error('[ORDER] Error in order confirmation handler', { error: error.message });
        return res.status(200).json({ ok: false, type: 'order_confirmation_error' });
    }
};

/**
 * Handle order request flow using modular services (FIXED FOR MULTI-PRODUCT)
 * Replace this function in your customerHandler.js
 */
const handleOrderRequest = async (tenant, from, orderDetails, conversation, res) => {
        // CRITICAL PATCH: Map products to orders if needed for multi-product support
        if (!orderDetails.orders && Array.isArray(orderDetails.products)) {
            orderDetails.orders = orderDetails.products;
        }
    try {
        console.log('[ORDER_REQUEST_DEBUG] ===================================');
        console.log('[ORDER_REQUEST_DEBUG] Raw orderDetails:', JSON.stringify(orderDetails, null, 2));
        console.log('[ORDER_REQUEST_DEBUG] isMultipleProducts:', orderDetails?.isMultipleProducts);
        console.log('[ORDER_REQUEST_DEBUG] isContextOrder:', orderDetails?.isContextOrder);
        console.log('[ORDER_REQUEST_DEBUG] orders array:', orderDetails?.orders);
        console.log('[ORDER_REQUEST_DEBUG] productCode:', orderDetails?.productCode);
        console.log('[ORDER_REQUEST_DEBUG] ===================================');
        
        // Handle context-based orders (quantity-only like "10ctns")
        if (orderDetails.isContextOrder) {
            console.log('[ORDER_REQUEST] Context-based order detected');
            
            if (!conversation || (!conversation.last_product_discussed && !conversation.last_quoted_products)) {
                await sendAndLogMessage(from, 
                    'Please specify which product you want to order.', 
                    tenant.id, 'context_order_missing_product');
                return res.status(200).json({ ok: true, type: 'context_order_missing_product' });
            }
            
            // Check if there are multiple quoted products
            let quotedProducts = [];
            try {
                if (conversation.last_quoted_products) {
                    quotedProducts = typeof conversation.last_quoted_products === 'string' 
                        ? JSON.parse(conversation.last_quoted_products)
                        : conversation.last_quoted_products;
                }
            } catch (e) {
                console.log('[ORDER_REQUEST] Error parsing last_quoted_products:', e.message);
            }
            
            console.log('[ORDER_REQUEST] Found quoted products:', quotedProducts.length);
            
            if (quotedProducts.length > 1) {
                // Multiple products - create order for each with INDIVIDUAL quantities from quotedProducts
                console.log('[ORDER_REQUEST] Creating orders for', quotedProducts.length, 'products with INDIVIDUAL quantities');
                orderDetails.orders = quotedProducts.map(p => ({
                    productCode: p.productCode,
                    productName: p.productName,
                    productId: p.productId,
                    quantity: p.quantity, // âœ… Use stored quantity, not orderDetails.quantity
                    unit: p.unit, // âœ… Use stored unit
                    isPieces: p.unit === 'pieces' || p.isPieces,
                    originalText: `${p.productCode} ${p.quantity} ${p.unit}`
                }));
                orderDetails.isMultipleProducts = true;
                orderDetails.isContextOrder = false;
                console.log('[ORDER_REQUEST] Converted to multi-product order:', orderDetails.orders.length, 'products');
                console.log('[ORDER_REQUEST] Order details:', orderDetails.orders.map(o => `${o.productCode}:${o.quantity} ${o.unit}`).join('; '));
            } else {
                // Single product or fallback to last_product_discussed
                const productCode = quotedProducts.length > 0 
                    ? quotedProducts[0].productCode 
                    : conversation.last_product_discussed.split(',')[0].trim();
                console.log('[ORDER_REQUEST] Using single product:', productCode);
                
                orderDetails.productCode = productCode;
                orderDetails.productName = productCode;
                orderDetails.isContextOrder = false; // Convert to regular order
            }
        }
        
        console.log('[ORDER_EXTRACT] Order details extracted:', orderDetails);
        console.log('[ORDER_EXTRACT] Is multiple products?', orderDetails.isMultipleProducts);
        console.log('[ORDER_EXTRACT] Number of products:', orderDetails.orders?.length || 1);
        
    // CRITICAL FIX: Always use processMultipleOrderRequest if more than one product, regardless of isMultipleProducts flag
    if (orderDetails.orders && orderDetails.orders.length > 1) {
            console.log('[ORDER_EXTRACT] Processing as MULTIPLE products with processMultipleOrderRequest');
            
            // Map 'orders' to 'products' for the processor
            const multiOrderData = {
                products: orderDetails.orders,
                isMultipleProducts: true
            };
            const result = await processMultipleOrderRequest(tenant.id, from, multiOrderData);
            
            if (result.success) {
                await sendAndLogMessage(from, result.message, tenant.id, 'multi_order_processed');
                
                // Update conversation state for multi-product
                if (conversation) {
                    const productSummary = orderDetails.orders.map(p => p.productName || p.productCode).join(', ');
                    await supabase
                        .from('conversations')
                        .update({ 
                            state: 'multi_product_order_discussion',
                            last_product_discussed: productSummary
                        })
                        .eq('id', conversation.id);
                }
                
                // Show cart and ask for confirmation
                const cartView = await viewCartWithDiscounts(tenant.id, from);
                const confirmationMsg = cartView + '\n\n' +
                    'Ready to place order? Reply "yes go ahead" to checkout.';
                
                await sendAndLogMessage(from, confirmationMsg, tenant.id, 'multi_cart_confirmation');
                
                return res.status(200).json({ ok: true, type: 'multi_order_extracted' });
            } else {
                await sendAndLogMessage(from, result.message, tenant.id, 'multi_order_error');
                return res.status(200).json({ ok: true, type: 'multi_order_error' });
            }
        } 
        // Single product order - use existing logic
        else {
            console.log('[ORDER_EXTRACT] Processing as SINGLE product with processOrderRequestEnhanced');
            
            // For single product, ensure we have the right structure
            const singleOrderDetails = orderDetails.orders ? orderDetails.orders[0] : orderDetails;
            
            const result = await processOrderRequestEnhanced(tenant.id, from, singleOrderDetails);
            
            if (result.success) {
                await sendAndLogMessage(from, result.message, tenant.id, 'order_processed');
                
                // Update conversation state to track order discussion
                if (conversation) {
                    await supabase
                        .from('conversations')
                        .update({ 
                            state: 'order_discussion',
                            last_product_discussed: result.product?.name || ''
                        })
                        .eq('id', conversation.id);
                }
                
                // Show cart and ask for confirmation
                const cartView = await viewCartWithDiscounts(tenant.id, from);
                const confirmationMsg = cartView + '\n\n' +
                    'Ready to place order? Reply "yes go ahead" to checkout.';
                
                await sendAndLogMessage(from, confirmationMsg, tenant.id, 'cart_confirmation');
                
                return res.status(200).json({ ok: true, type: 'order_extracted' });
            } else {
                await sendAndLogMessage(from, result.message, tenant.id, 'order_error');
                return res.status(200).json({ ok: true, type: 'order_error' });
            }
        }
    } catch (error) {
        console.error('Error in order request handler:', error.message);
        return res.status(200).json({ ok: false, type: 'order_request_error' });
    }
};

/**
 * Transcribe audio message using OpenAI Whisper API
 */
const transcribeAudio = async (audioUrl) => {
    try {
        console.log('[AUDIO_TRANSCRIPTION] Starting transcription for URL:', audioUrl);

        // Download audio file from WhatsApp URL
        const audioResponse = await fetch(audioUrl);
        if (!audioResponse.ok) {
            throw new Error(`Failed to download audio: ${audioResponse.statusText}`);
        }

        const audioBuffer = await audioResponse.buffer();
        
        // Create form data for OpenAI API
        const formData = new FormData();
        formData.append('file', audioBuffer, {
            filename: 'audio.ogg',
            contentType: 'audio/ogg'
        });
        formData.append('model', 'whisper-1');
        formData.append('language', 'en'); // Can be made dynamic based on tenant settings

        // Call OpenAI Whisper API
        const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                ...formData.getHeaders()
            },
            body: formData
        });

        if (!response.ok) {
            throw new Error(`OpenAI API error: ${response.statusText}`);
        }

        const result = await response.json();
        console.log('[AUDIO_TRANSCRIPTION] Transcription successful:', result.text);
        
        return result.text || '';

    } catch (error) {
        console.error('[AUDIO_TRANSCRIPTION] Error transcribing audio:', error.message);
        return null;
    }
};

/**
 * Handle transcribed audio message
 */
const handleTranscribedMessage = async (transcription, tenant, from, req, res) => {
    try {
        if (!transcription || transcription.trim() === '') {
            await sendMessage(from, "Sorry, I couldn't understand your voice message. Please try sending a text message or speak more clearly.");
            return res.status(200).json({ ok: true, type: 'transcription_failed' });
        }

        console.log('[AUDIO_TRANSCRIPTION] Processing transcribed message:', transcription);

        // Create a modified request object with transcribed text
        const modifiedReq = {
            ...req,
            message: {
                ...req.message,
                text: { body: transcription },
                type: 'text' // Treat as text message after transcription
            }
        };

        // Process as normal text message
        return await handleCustomerTextMessage(modifiedReq, res);

    } catch (error) {
        console.error('[AUDIO_TRANSCRIPTION] Error handling transcribed message:', error.message);
        await sendMessage(from, "Sorry, there was an error processing your voice message. Please try again.");
        return res.status(200).json({ ok: false, type: 'transcription_processing_error' });
    }
};

/**
 * Handle admin login command
 */
const handleLoginCommand = async (tenantId, phoneNumber) => {
    try {
        // Generate secure magic link token
        const token = require('crypto').randomBytes(32).toString('hex');
        const expiresAt = new Date(Date.now() + 30 * 60 * 1000); // 30 minutes
        
        // Store token in tenant record
        await supabase
            .from('tenants')
            .update({
                web_auth_token: token,
                web_auth_token_expires_at: expiresAt.toISOString()
            })
            .eq('id', tenantId);
        
        // Generate dashboard URL (adjust base URL as needed)
        const baseUrl = 'https://sak-whatsapp-ai-sales-assist.wl.r.appspot.com';
        const loginUrl = `${baseUrl}/dashboard.html?token=${token}`;
        
        return {
            success: true,
            message: `ðŸ” **Admin Dashboard Access**\n\nYour secure login link:\n${loginUrl}\n\nâ° **Expires in 30 minutes**\nðŸ”’ **For security, this link can only be used once**\n\nClick the link to access your admin dashboard.`
        };
        
    } catch (error) {
        console.error('Login command error:', error);
        return {
            success: false,
            message: 'Sorry, there was an error generating your login link. Please try again.'
        };
    }
};

/**
 * Main customer handler - refactored and modularized
 */
const handleCustomer = async (req, res) => {
    const { message, tenant } = req;
    const from = message.from;

    // Handle audio messages
    if (message.type === 'audio') {
        console.log('[AUDIO_MESSAGE] Received audio message from:', from);
        
        try {
            const audioUrl = message.audio?.url;
            if (!audioUrl) {
                await sendMessage(from, "Sorry, I couldn't access your voice message. Please try again.");
                return res.status(200).json({ ok: true, type: 'audio_url_missing' });
            }

            const transcription = await transcribeAudio(audioUrl);
            if (transcription) {
                // Track transcription cost (Whisper API)
                await trackResponse(tenant.id, 'audio_transcription', 'ai', 0.006);
                
                // Log the audio message as transcribed text
                await logMessage(tenant.id, from, 'user', transcription, 'audio_transcribed');
                
                // Process transcribed text as normal user query
                return await handleTranscribedMessage(transcription, tenant, from, req, res);
            } else {
                await sendMessage(from, "Sorry, I couldn't transcribe your voice message. Please try sending a text message.");
                return res.status(200).json({ ok: true, type: 'transcription_failed' });
            }
        } catch (error) {
            console.error('[AUDIO_MESSAGE] Error processing audio message:', error.message);
            await sendMessage(from, "Sorry, there was an error processing your voice message. Please try again with text.");
            return res.status(200).json({ ok: false, type: 'audio_processing_error' });
        }
    }

    // Continue with existing text message handling
    return await handleCustomerTextMessage(req, res);
};

/**
 * Handle text messages (extracted from original handleCustomer function).
 */
const handleCustomerTextMessage = async (req, res) => {
    console.log('[DEBUG] handleCustomerTextMessage called for:', req?.message?.from, '| text:', req?.message?.text?.body);

    const { message, tenant } = req;
    const from = message.from;
    const userQuery = message.text.body;

    // Initialize conversationContext to prevent "before initialization" errors
    let conversationContext = {};

    console.log('[STATE_CHECK_START] About to check conversation state for:', from);

    // --- CRITICAL: Check for stuck GST state FIRST, before anything else ---
    const { data: conversationCheck, error: convError } = await supabase
        .from('conversations')
        .select('id, state, updated_at, last_quoted_products, last_product_discussed')
        .eq('tenant_id', tenant.id)
        .eq('end_user_phone', from)
        .single();
    
    console.log('[STATE_CHECK_RESULT]', {
        found: !!conversationCheck,
        error: convError?.message,
        state: conversationCheck?.state || 'NULL',
        id: conversationCheck?.id,
        updated: conversationCheck?.updated_at
    });
    
    if (conversationCheck && conversationCheck.state === 'awaiting_gst_info') {
        console.log('[STUCK_STATE_CHECK] Conversation in awaiting_gst_info state');
        
        // TIMEOUT CHECK: If state has been awaiting_gst_info for more than 10 minutes, auto-clear
        const stateAge = Date.now() - new Date(conversationCheck.updated_at).getTime();
        const tenMinutes = 10 * 60 * 1000;
        
        if (stateAge > tenMinutes) {
            console.log('[STUCK_STATE_TIMEOUT] State is stale (>10 mins), auto-clearing:', {
                ageMinutes: Math.floor(stateAge / 60000),
                updated: conversationCheck.updated_at
            });
            
            await supabase
                .from('conversations')
                .update({ 
                    state: null, 
                    context_data: null 
                })
                .eq('id', conversationCheck.id);
            
            console.log('[STUCK_STATE_TIMEOUT] âœ… State cleared due to timeout');
            // Continue processing message normally
        } else {
            // State is recent, check if customer already has GST data (state is stuck)
            const { data: existingProfile, error: profileError } = await supabase
                .from('customer_profiles')
                .select('gst_number, onboarding_completed, phone')
                .eq('tenant_id', tenant.id)
                .eq('phone', from)
                .single();
            
            console.log('[STUCK_STATE_CHECK] Profile lookup:', {
                found: !!existingProfile,
                error: profileError?.message,
                gst_number: existingProfile?.gst_number || 'MISSING',
                onboarding_completed: existingProfile?.onboarding_completed || false,
                phone: existingProfile?.phone || 'MISSING',
                lookupPhone: from
            });
            
            // AGGRESSIVE FIX: Clear state if customer has ANY GST number, regardless of onboarding flag
            if (existingProfile?.gst_number) {
                console.log('[STUCK_STATE_FIX] Customer has GST - force clearing awaiting_gst_info state');
            
                // Clear the stuck state immediately
                const { error: updateError } = await supabase
                    .from('conversations')
                    .update({ 
                        state: null, 
                        context_data: null 
                    })
                    .eq('id', conversationCheck.id);
                
                if (updateError) {
                    console.error('[STUCK_STATE_FIX] Failed to clear state:', updateError.message);
                } else {
                    console.log('[STUCK_STATE_FIX] âœ… State cleared successfully');
                }
            } else {
                console.log('[STUCK_STATE_CHECK] No GST found - keeping awaiting_gst_info state (recent, <10 mins)');
            }
        }
    }

    // --- EARLY CHECK: Shipping address update BEFORE AI router ---
    const updateAddressPatterns = [
        /update.*shipping.*address/i,
        /update.*shipping.*details/i,
        /change.*shipping.*address/i,
        /change.*shipping.*details/i,
        /modify.*shipping.*address/i,
        /modify.*shipping.*details/i,
        /new.*shipping.*address/i,
        /update.*delivery.*address/i,
        /change.*delivery.*address/i
    ];

    if (updateAddressPatterns.some(pattern => pattern.test(userQuery))) {
        console.log('[SHIPPING_UPDATE] Customer requesting address update (early check)');
        try {
            const { handleShippingAddressUpdate } = require('../../services/shippingInfoService');
            await handleShippingAddressUpdate(tenant.id, from);
            return res.status(200).json({ ok: true, type: 'address_update_requested' });
        } catch (updateError) {
            console.error('[SHIPPING_UPDATE] Error:', updateError.message);
            await sendAndLogMessage(from, 'Sorry, there was an error. Please try again.', tenant.id, 'shipping_update_error');
            return res.status(200).json({ ok: true, type: 'shipping_update_error' });
        }
    }

    // --- CRITICAL: Check conversation state FIRST (before AI routing) ---
    // If user is in a specific state (awaiting_address_update, awaiting_shipping_info, etc.),
    // we should NOT run AI router - the state handler should process the message
    if (conversationCheck && (conversationCheck.state === 'awaiting_address_update' || conversationCheck.state === 'awaiting_shipping_info')) {
        console.log(`[STATE_CHECK] User in state: ${conversationCheck.state} - skipping AI router, letting state handler process`);
        // Don't return - let it fall through to state handler below
    } else {
        // --- CRITICAL: Check for order confirmation BEFORE smart router ---
        // This prevents "confirm order", "yes", etc. from being interpreted as general queries
        // Use conversationCheck since full conversation object isn't loaded yet
        const earlyOrderCheck = conversationCheck ? await isOrderConfirmationEnhanced(userQuery, conversationCheck, tenant.id) : false;
        if (earlyOrderCheck && conversationCheck) {
            console.log('[EARLY_CHECK] Order confirmation detected - skipping smart router, going to checkout');
            // Don't return here - let it fall through to the order confirmation logic below
        } else {
            // --- PATCH: Try Smart Response Router FIRST for all queries (AI-powered, not regex-gated) ---
            const smartResponseRouter = require('../../services/smartResponseRouter');
            const smartResult = await smartResponseRouter.getSmartResponse(
                userQuery,      // First param: userQuery
                tenant.id,      // Second param: tenantId
                from            // Third param: phoneNumber
            );
            
            console.log('[DEBUG_FLOW] Smart Response Result:', smartResult?.status || 'NOT_FOUND');
            
            if (smartResult && smartResult.status === 'success') {
                console.log('[DEBUG_FLOW] âœ… Smart Response Router handled query (AI-powered)');
                await sendAndLogMessage(from, smartResult.message, tenant.id, 'smart_response');
                return res.status(200).json({ ok: true, type: 'smart_response' });
            }
        }
    }

    // Patch: Save WhatsApp profile name to conversation if present
    if (message.wa_profile_name) {
        await supabase
            .from('conversations')
            .update({ wa_profile_name: message.wa_profile_name })
            .eq('tenant_id', tenant.id)
            .eq('end_user_phone', from);
    }

    debug.trace(req._rid, 'customer.message', { 
        from: from,
        queryLength: userQuery?.length || 0,
        tenantId: tenant.id
    });

    try {
    // Log the incoming user message
    await logMessage(tenant.id, from, 'user', userQuery, 'user_input');
    // Track customer message for 5-minute timeout
    await trackCustomerMessage(tenant.id, from, userQuery);


                // Get existing conversation and state
                const { data: conversationData } = await supabase
                        .from('conversations')
                        .select('*')
                        .eq('tenant_id', tenant.id)
                        .eq('end_user_phone', from)
                        .single();
                
                let conversation = conversationData; // Use let so we can reassign it later if needed

                // Initialize conversationContext to prevent "before initialization" errors
                let conversationContext = conversation;


                // === AWAITING ADDRESS UPDATE HANDLER ===
                // Check if user is providing updated address
                if (conversation && conversation.state === 'awaiting_address_update') {
                    console.log('[SHIPPING_UPDATE] Processing updated address');
                    try {
                        const { processAddressUpdate } = require('../../services/shippingInfoService');
                        const result = await processAddressUpdate(tenant.id, from, userQuery);
                        
                        if (result.success) {
                            console.log('[SHIPPING_UPDATE] Address updated successfully');
                            // Message already sent by processAddressUpdate
                            return res.status(200).json({ ok: true, type: 'address_updated' });
                        } else {
                            console.error('[SHIPPING_UPDATE] Failed:', result.error);
                            await sendAndLogMessage(from, result.message, tenant.id, 'address_update_error');
                            return res.status(200).json({ ok: true, type: 'address_update_error' });
                        }
                    } catch (updateError) {
                        console.error('[SHIPPING_UPDATE] Error:', updateError.message);
                        await sendAndLogMessage(from, 'Sorry, there was an error updating your address. Please try again.', tenant.id, 'address_update_error');
                        return res.status(200).json({ ok: true, type: 'address_update_error' });
                    }
                }

                // === SHIPPING INFO COLLECTION HANDLER ===
                // Check if user is responding with shipping details after order placement
                if (conversation && conversation.state === 'awaiting_shipping_info' && conversation.context_data) {
                    console.log('[SHIPPING_INFO] User responding with shipping details');
                    try {
                        const contextData = safeParseContextData(conversation.context_data);
                        const orderId = contextData.pending_shipping_order_id;
                        
                        if (orderId) {
                            const { processShippingInfo } = require('../../services/shippingInfoService');
                            const result = await processShippingInfo(tenant.id, from, userQuery, orderId);
                            
                            if (result.success) {
                                console.log('[SHIPPING_INFO] Successfully processed shipping details for order:', orderId);
                                await sendAndLogMessage(from, result.message, tenant.id, 'shipping_info_collected');
                                return res.status(200).json({ ok: true, type: 'shipping_info_collected' });
                            } else {
                                console.error('[SHIPPING_INFO] Failed to process:', result.error);
                                await sendAndLogMessage(from, result.message, tenant.id, 'shipping_info_error');
                                return res.status(200).json({ ok: true, type: 'shipping_info_error' });
                            }
                        }
                    } catch (shippingError) {
                        console.error('[SHIPPING_INFO] Error processing shipping details:', shippingError.message);
                        await sendAndLogMessage(from, 'Sorry, there was an error processing your shipping details. Please try again.', tenant.id, 'shipping_info_error');
                        return res.status(200).json({ ok: true, type: 'shipping_info_error' });
                    }
                }

                // --- PATCH: If last bot message was a name request, treat this reply as the user's name ---
                const lastBotMsg = await supabase
                        .from('messages')
                        .select('id, text, sender_type')
                        .eq('tenant_id', tenant.id)
                        .eq('to', from)
                        .order('created_at', { ascending: false })
                        .limit(1)
                        .maybeSingle();

                const nameRequestPatterns = [
                    /may I know your name/i,
                    /who am I speaking with/i,
                    /please tell me your name/i,
                    /mind letting me know your name/i,
                    /share your business card/i
                ];
                const lastBotAskedName = lastBotMsg?.data && lastBotMsg.data.sender_type === 'bot' &&
                    nameRequestPatterns.some(pat => pat.test(lastBotMsg.data.text));

                if (lastBotAskedName && userQuery && userQuery.length < 40 && !userQuery.match(/\b(order|price|product|help|hi|hello|status|login|yes|no|cart|checkout|invoice|history|segment|broadcast)\b/i)) {
                    // Save as name in conversation and customer profile
                    await supabase
                        .from('conversations')
                        .update({ customer_name: userQuery })
                        .eq('tenant_id', tenant.id)
                        .eq('end_user_phone', from);
                    await supabase
                        .from('customer_profiles')
                        .update({ first_name: userQuery })
                        .eq('tenant_id', tenant.id)
                        .eq('phone', from.replace(/@.*$/,'').replace(/\D/g,''));
                    // Greet the user by name and continue
                    const greetings = [
                        `Hi ${userQuery}! How can I help you today?`,
                        `Hey ${userQuery}! What can I do for you?`,
                        `Hello ${userQuery}! How are you doing?`,
                        `Hi there ${userQuery}! Need something?`
                    ];
                    const greeting = greetings[Math.floor(Math.random() * greetings.length)];
                    await sendAndLogMessage(from, greeting, tenant.id, 'name_captured');
                    return res.status(200).json({ ok: true, type: 'name_captured' });
                }

                // Robust customer profile lookup using normalized phone
                let customerProfile = await getCustomerProfile(tenant.id, from);
                if (!customerProfile) {
                        // Log for debugging if not found
                        console.warn('[CUSTOMER_PROFILE_LOOKUP] No profile found for', from, 'after normalization');
                } else {
                        console.log('[CUSTOMER_PROFILE_LOOKUP] Loaded profile:', customerProfile);
                }


        // === ONBOARDING FLOW - HIGHEST PRIORITY ===
        console.log('[DEBUG_FLOW] STEP 0: Checking onboarding status...');
        
        // Check if customer is in onboarding flow
        const onboardingResult = await handleOnboardingFlow(tenant.id, from, userQuery, conversation);
        if (onboardingResult) {
            console.log('[ONBOARDING] Flow handled:', onboardingResult.success);
            await sendAndLogMessage(from, onboardingResult.message, tenant.id, 'onboarding_flow');
            if (onboardingResult.completed) {
                console.log('[ONBOARDING] Onboarding completed successfully');
            }
            return res.status(200).json({ ok: true, type: 'onboarding' });
        }

        // Check if new customer needs onboarding
        if (!conversation || conversation.state === 'new') {
            console.log('[DEBUG_FLOW] New customer detected - checking onboarding needs');
            const status = await checkOnboardingStatus(tenant.id, from);
            
            if (status.needsOnboarding) {
                console.log('[ONBOARDING] Starting onboarding for new customer');
                const welcomeMessage = await startOnboarding(tenant.id, from);
                await sendAndLogMessage(from, welcomeMessage, tenant.id, 'onboarding_start');
                return res.status(200).json({ ok: true, type: 'onboarding_start' });
            }
        }
        
        // === GST INFO COLLECTION STATE ===
        if (conversation && conversation.state === 'awaiting_gst_info') {
            console.log('[GST_COLLECTION] Processing GST info response');
            
            // CRITICAL: Check if customer already has GST data (state got stuck)
            const normalizedPhone = from.replace(/@.*$/,'').replace(/\D/g,'');
            const { data: existingProfile } = await supabase
                .from('customer_profiles')
                .select('gst_number, onboarding_completed')
                .eq('tenant_id', tenant.id)
                .eq('phone', normalizedPhone)
                .single();
            
            if (existingProfile?.gst_number && existingProfile?.onboarding_completed) {
                console.log('[GST_COLLECTION] Customer already has GST data - clearing stuck state');
                
                // Reset conversation state and continue with normal flow
                await supabase
                    .from('conversations')
                    .update({ 
                        state: null, 
                        context_data: null 
                    })
                    .eq('id', conversation.id);
                
                console.log('[GST_COLLECTION] State cleared - continuing with normal message processing');
                // Don't return - let the message be processed normally below
            } else {
                // Customer doesn't have GST yet - proceed with collection
                
                // Check if user wants to skip
                if (/\b(skip|later|proceed\s+without|no\s+gst)\b/i.test(userQuery)) {
                    console.log('[GST_COLLECTION] Customer chose to skip GST');
                
                // Mark onboarding as completed (without GST)
                const normalizedPhone = from.replace(/@.*$/,'').replace(/\D/g,'');
                await supabase
                    .from('customer_profiles')
                    .update({
                        onboarding_completed: true,
                        updated_at: new Date().toISOString()
                    })
                    .eq('tenant_id', tenant.id)
                    .eq('phone', normalizedPhone);
                
                // Get pending checkout context
                let contextData = null;
                try {
                    contextData = safeParseContextData(conversation.context_data);
                } catch (e) {
                    console.warn('[GST_COLLECTION] Failed to parse context_data');
                }
                
                // Restore discount state and proceed to checkout
                if (contextData && contextData.pendingCheckout) {
                    await supabase
                        .from('conversations')
                        .update({
                            state: 'discount_approved',
                            context_data: JSON.stringify({
                                approvedDiscount: contextData.approvedDiscount
                            })
                        })
                        .eq('id', conversation.id);
                    
                    console.log('[GST_COLLECTION] Proceeding with checkout (without GST)');
                    const result = await checkoutWithDiscounts(tenant, from);
                    await sendAndLogMessage(from, result, tenant.id, 'checkout_confirmed');
                    
                    if (tenant.payment_qr_code_url) {
                        try {
                            const qrMessage = "QR code available for payment. Please contact us for the QR code image.";
                            await sendAndLogMessage(from, qrMessage, tenant.id, 'qr_code_available');
                        } catch (qrError) {
                            console.warn('Failed to send QR code message:', qrError.message);
                        }
                    }
                    
                    return res.status(200).json({ ok: true, type: 'order_confirmed' });
                } else {
                    const skipMessage = "Okay, you can provide GST details later. How can I help you today?";
                    await sendAndLogMessage(from, skipMessage, tenant.id, 'gst_skipped');
                    
                    // Reset conversation state
                    await supabase
                        .from('conversations')
                        .update({ state: null, context_data: null })
                        .eq('id', conversation.id);
                    
                    return res.status(200).json({ ok: true, type: 'gst_skipped' });
                }
            }
            
            // Try to extract GST info from message
            console.log('[GST_COLLECTION] Attempting to extract GST info from:', userQuery);
            
            try {
                const { extractCustomerInfoAI } = require('../../services/customerOnboardingService');
                const extracted = await extractCustomerInfoAI(userQuery, 'business_info');
                
                if (extracted.gst || extracted.company || extracted.address) {
                    console.log('[GST_COLLECTION] Extracted info:', extracted);
                    
                    // Update customer profile
                    const updateData = {
                        onboarding_completed: true,
                        updated_at: new Date().toISOString()
                    };
                    
                    if (extracted.gst) updateData.gst_number = extracted.gst;
                    if (extracted.company) updateData.company = extracted.company;
                    if (extracted.address) updateData.address = extracted.address;
                    
                    // Normalize phone number for database lookup (same as getCustomerProfile)
                    const normalizedPhone = (from || '').toString().replace(/@.*$/,'').replace(/\D/g,'');
                    
                    // Use upsert to create profile if it doesn't exist
                    await supabase
                        .from('customer_profiles')
                        .upsert({
                            ...updateData,
                            tenant_id: tenant.id,
                            phone: normalizedPhone
                        }, {
                            onConflict: 'tenant_id,phone'
                        });
                    
                    let confirmMsg = "âœ… *Thank you for providing your business details!*\n\n";
                    if (extracted.gst) confirmMsg += `ðŸ“‹ GST: ${extracted.gst}\n`;
                    if (extracted.company) confirmMsg += `ðŸ¢ Company: ${extracted.company}\n`;
                    if (extracted.address) confirmMsg += `ðŸ“ Address: ${extracted.address}\n`;
                    confirmMsg += `\n*Processing your order now...*`;
                    
                    await sendAndLogMessage(from, confirmMsg, tenant.id, 'gst_collected');
                    
                    // Get pending checkout context and proceed
                    let contextData = null;
                    try {
                        contextData = safeParseContextData(conversation.context_data);
                    } catch (e) {
                        console.warn('[GST_COLLECTION] Failed to parse context_data');
                    }
                    
                    if (contextData && contextData.pendingCheckout) {
                        await supabase
                            .from('conversations')
                            .update({
                                state: 'discount_approved',
                                context_data: JSON.stringify({
                                    approvedDiscount: contextData.approvedDiscount
                                })
                            })
                            .eq('id', conversation.id);
                        
                        console.log('[GST_COLLECTION] Proceeding with checkout (with GST)');
                        const result = await checkoutWithDiscounts(tenant, from);
                        await sendAndLogMessage(from, result, tenant.id, 'checkout_confirmed');
                        
                        if (tenant.payment_qr_code_url) {
                            try {
                                const qrMessage = "QR code available for payment. Please contact us for the QR code image.";
                                await sendAndLogMessage(from, qrMessage, tenant.id, 'qr_code_available');
                            } catch (qrError) {
                                console.warn('Failed to send QR code message:', qrError.message);
                            }
                        }
                        
                        return res.status(200).json({ ok: true, type: 'order_confirmed' });
                    }
                } else {
                    console.log('[GST_COLLECTION] No valid GST info extracted');
                    const retryMsg = "I couldn't extract GST details from your message.\n\n" +
                        "Please provide:\n" +
                        "â€¢ GST Number (15 digits)\n" +
                        "â€¢ Company Name\n" +
                        "â€¢ Business Address\n\n" +
                        "Or type 'skip' to proceed without GST.";
                    await sendAndLogMessage(from, retryMsg, tenant.id, 'gst_collection_retry');
                    return res.status(200).json({ ok: true, type: 'gst_collection_retry' });
                }
            } catch (extractError) {
                console.error('[GST_COLLECTION] Error extracting info:', extractError.message);
                const errorMsg = "I'm having trouble processing that. Could you please share:\n\n" +
                    "â€¢ Your GST Number\n" +
                    "â€¢ Company Name\n" +
                    "â€¢ Address\n\n" +
                    "Or type 'skip' to continue without GST.";
                await sendAndLogMessage(from, errorMsg, tenant.id, 'gst_collection_error');
                return res.status(200).json({ ok: true, type: 'gst_collection_error' });
            }
            } // End of else block for customers without GST
        }

        // === PRIORITY CHECKS (modularized) ===
        const {
          handleUnsubscribeCheck,
          handleOfficeHoursCheck,
          handleMenuCheck,
          handleAdminLoginCheck,
          handleEarlyZohoHandlers
        } = require('./customer/priorityChecks');

        // Unsubscribe
        if (await handleUnsubscribeCheck(userQuery, from, tenant, sendAndLogMessage, res)) return;

        // Multi-step Conversation State Handling (already modularized above)

        // Office Hours
        if (await handleOfficeHoursCheck(userQuery, from, tenant, sendAndLogMessage, res)) return;

        // Menu
        if (await handleMenuCheck(userQuery, from, tenant, sendAndLogMessage, res)) return;

        // Shipment Tracking
        if (await handleShipmentTracking(conversation?.id, userQuery, from, conversationContext, sendAndLogMessage)) return;

        // Admin Login
        if (await handleAdminLoginCheck(userQuery, from, tenant, sendAndLogMessage, handleLoginCommand, res)) return;

        // Early Zoho Handlers
        if (await handleEarlyZohoHandlers(userQuery, tenant, from, conversation, handleInvoiceRequest, handleOrderApproval, sendAndLogMessage, res)) return;

        // === COMPREHENSIVE DEBUG LOGGING ===
        console.log('=====================================');
        console.log('[DEBUG_FLOW] User Query:', userQuery);
        console.log('[DEBUG_FLOW] Current timestamp:', new Date().toISOString());
        console.log('[DEBUG_FLOW] About to start main processing flow...');
        console.log('=====================================');

        // === AI-POWERED INTENT RECOGNITION ===
        console.log('[INTENT] Starting AI intent recognition...');
        const intentContext = {
            conversationState: conversation?.state,
            hasQuotedProducts: !!conversation?.last_quoted_products,
            hasCart: false, // Will be checked later
            lastIntent: conversation?.last_intent
        };
        
        // Quick check for cart
        try {
            const { data: cartCheck } = await supabase
                .from('carts')
                .select('id, cart_items(id)')
                .eq('conversation_id', conversation?.id)
                .single();
            intentContext.hasCart = cartCheck && cartCheck.cart_items && cartCheck.cart_items.length > 0;
        } catch (err) {
            // Cart doesn't exist, that's fine
        }

        const intentResult = await recognizeIntent(userQuery, intentContext);
        console.log('[INTENT] Result:', intentResult.intent, '| Confidence:', intentResult.confidence, '| Reasoning:', intentResult.reasoning);

        // === REMOVE PRODUCT FROM CART ===
        if (intentResult.intent === 'REMOVE_PRODUCT' && intentResult.confidence > 0.7) {
            const { removeCartItem } = require('../../services/cartService');
            // Try to extract product code or name
            let productCode = intentResult.extractedData?.productCode;
            if (!productCode) {
                // Fallback: try to extract from message
                const codeMatch = userQuery.match(/(\d+[x*]\d+)/);
                productCode = codeMatch ? codeMatch[1] : userQuery;
            }
            const removeResult = await removeCartItem(tenant.id, from, productCode);
            await sendAndLogMessage(from, removeResult.message, tenant.id, 'cart_item_removed');
            return res.status(200).json({ ok: true, type: 'cart_item_removed' });
        }

        // === UPDATE QUANTITY OF PRODUCT IN CART ===
        if (intentResult.intent === 'QUANTITY_UPDATE' && intentResult.confidence > 0.7) {
            const { updateCartQuantity } = require('../../services/quantityChangeService');
            let productCode = intentResult.extractedData?.productCode;
            let newQuantity = intentResult.extractedData?.newQuantity;
            if (!productCode || !newQuantity) {
                // Fallback: try to extract from message
                const codeMatch = userQuery.match(/(\d+[x*]\d+)/);
                productCode = codeMatch ? codeMatch[1] : null;
                const qtyMatch = userQuery.match(/(\d+)\s*(ctns?|cartons?)/);
                newQuantity = qtyMatch ? parseInt(qtyMatch[1]) : null;
            }
            if (!productCode || !newQuantity) {
                await sendAndLogMessage(from, 'Sorry, I could not understand which product or quantity to update.', tenant.id, 'cart_quantity_error');
                return res.status(200).json({ ok: false, type: 'cart_quantity_error' });
            }
            const updateResult = await updateCartQuantity(tenant.id, from, newQuantity, productCode);
            await sendAndLogMessage(from, updateResult.message, tenant.id, 'cart_quantity_updated');
            return res.status(200).json({ ok: true, type: 'cart_quantity_updated' });
        }
        
        // === AI-POWERED CONTEXT ANALYSIS ===
        // Use AI to understand the TRUE intent based on conversation context
        // This replaces all regex pattern matching!
        // ONLY RUN FOR ACTIVE DISCOUNT NEGOTIATION - NOT for fresh pricing inquiries
        let aiContextAnalysis = null;
        if (conversationCheck && (conversationCheck.state === 'discount_offered' || conversationCheck.state === 'discount_approved')) {
            console.log('[AI_CONTEXT] Running AI context analysis for state:', conversationCheck.state);
            
            // Get recent conversation history
            const { data: recentMessages } = await supabase
                .from('messages')
                .select('sender, content, created_at')
                .eq('conversation_id', conversationCheck.id)
                .order('created_at', { ascending: false })
                .limit(6);
            
            aiContextAnalysis = await analyzeConversationContext(
                userQuery,
                recentMessages || [],
                conversationCheck
            );
            
            console.log('[AI_CONTEXT] Analysis:', {
                intent: aiContextAnalysis.intent,
                action: aiContextAnalysis.action,
                confidence: aiContextAnalysis.confidence
            });
            
            // If AI is confident and disagrees with basic intent recognition, use AI's analysis
            if (aiContextAnalysis.confidence > 0.7) {
                if (aiContextAnalysis.intent !== intentResult.intent) {
                    console.log('[AI_CONTEXT] âš ï¸ AI OVERRIDE: Changing intent from', intentResult.intent, 'to', aiContextAnalysis.intent);
                    console.log('[AI_CONTEXT] Reasoning:', aiContextAnalysis.reasoning);
                }
                
                // Use AI's intent
                intentResult.intent = aiContextAnalysis.intent;
                intentResult.confidence = aiContextAnalysis.confidence;
                intentResult.reasoning = aiContextAnalysis.reasoning;
                
                // Handle quantity updates
                if (aiContextAnalysis.action === 'RECALCULATE_DISCOUNT' && aiContextAnalysis.extractedData?.quantity) {
                    const newQuantity = aiContextAnalysis.extractedData.quantity;
                    console.log('[AI_CONTEXT] Quantity update detected:', newQuantity, 'cartons');
                    
                    // Update conversation with new quantity
                    if (conversationCheck.last_quoted_products) {
                        try {
                            const quotedProducts = typeof conversationCheck.last_quoted_products === 'string'
                                ? JSON.parse(conversationCheck.last_quoted_products)
                                : conversationCheck.last_quoted_products;
                            
                            const updatedProducts = quotedProducts.map(p => ({
                                ...p,
                                quantity: newQuantity
                            }));
                            
                            await supabase
                                .from('conversations')
                                .update({
                                    last_quoted_products: JSON.stringify(updatedProducts),
                                    state: null,
                                    context_data: null
                                })
                                .eq('id', conversationCheck.id);
                            
                            console.log('[AI_CONTEXT] Updated quantity to', newQuantity, 'cartons and reset state');
                            
                            conversationCheck.last_quoted_products = JSON.stringify(updatedProducts);
                            conversationCheck.state = null;
                            conversationCheck.context_data = null;
                        } catch (e) {
                            console.warn('[AI_CONTEXT] Error updating quantity:', e.message);
                        }
                    }
                    
                    // Force discount request intent
                    intentResult.intent = 'DISCOUNT_REQUEST';
                    intentResult.confidence = 0.95;
                }
            }
        }
        
        // Save detected intent for future context
        if (intentResult.confidence > 0.7 && conversation?.id) {
            try {
                await supabase
                    .from('conversations')
                    .update({ last_intent: intentResult.intent })
                    .eq('id', conversation.id);
            } catch (err) {
                console.warn('[INTENT] Failed to save intent:', err.message);
            }
        }

    // === CRITICAL: SMART RESPONSE ROUTER FIRST ===
    // BUT: Skip smart router if this is a discount negotiation (no product codes mentioned)
    // NOTE: intentResult is available here; isDiscountIntent is declared later.
    const isDiscountNegotiationWithoutProducts = (intentResult && intentResult.intent === 'DISCOUNT_REQUEST' && intentResult.confidence > 0.6) && !/\d+[x*]\d+/i.test(userQuery);
        
        console.log('[DEBUG_FLOW] STEP 1: Checking Smart Response Router...');
        console.log('[DEBUG_FLOW] Skip Smart Router for discount?', isDiscountNegotiationWithoutProducts);
        console.log('[DEBUG_FLOW] Query being sent to getSmartResponse:', userQuery);
        
        try {
            // Skip smart router if it's a discount request without specific product codes
            // This allows "give me best price" (after price inquiry) to go to discount handler
            const smartResponse = isDiscountNegotiationWithoutProducts ? null : await getSmartResponse(userQuery, tenant.id, from);
            console.log('[DEBUG_FLOW] Smart Response Result:', smartResponse ? 'FOUND' : 'NOT_FOUND');
            
            if (smartResponse) {
                console.log('[DIAGNOSTIC] Smart Router returned response type:', typeof smartResponse);
                console.log('[DIAGNOSTIC] Smart Router response keys:', Object.keys(smartResponse));
                console.log('[DIAGNOSTIC] Has quotedProducts?', !!smartResponse.quotedProducts);
                console.log('[DIAGNOSTIC] QuotedProducts length:', smartResponse.quotedProducts?.length || 0);
                console.log('[DIAGNOSTIC] QuotedProducts type:', typeof smartResponse.quotedProducts);
                console.log('[DIAGNOSTIC] QuotedProducts is array?', Array.isArray(smartResponse.quotedProducts));
                
                if (smartResponse.quotedProducts && smartResponse.quotedProducts.length > 0) {
                    console.log('[DIAGNOSTIC] â­ QuotedProducts content:', JSON.stringify(smartResponse.quotedProducts, null, 2));
                } else {
                    console.log('[DIAGNOSTIC] âš ï¸ No quotedProducts or empty array');
                }
                
                console.log('[DEBUG_FLOW] Smart Response Details:', {
                    source: smartResponse.source,
                    responseLength: smartResponse.response?.length || 0,
                    responsePreview: smartResponse.response?.substring(0, 100) + '...'
                });
                console.log('[DEBUG_FLOW] SMART ROUTER HANDLING - RETURNING EARLY');
                console.log('[SMART_ROUTER] Price inquiry handled by smart router:', smartResponse.source);
                await trackResponse(tenant.id, userQuery, 'database', 0.0002);

                // NEW: Save quoted products if available (PRESERVED FROM WORKING VERSION)
                console.log('[SAVE_CHECK] Checking if should save quoted products:', {
                    hasQuotedProducts: !!smartResponse.quotedProducts,
                    quotedProductsLength: smartResponse.quotedProducts?.length || 0,
                    hasConversation: !!conversation,
                    conversationId: conversation?.id
                });
                
                if (smartResponse.quotedProducts && smartResponse.quotedProducts.length > 0 && conversation) {
                    console.log('[PRICE_SAVE] âœ… All conditions met - proceeding with save');
                    try {
                        const summary = smartResponse.quotedProducts
                            .map(o => (o.productName || o.productCode || '').toString().trim())
                            .filter(Boolean)
                            .join(', ');

                        console.log('[SAVE_QUOTED] Raw quotedProducts before stringify:', JSON.stringify(smartResponse.quotedProducts, null, 2));

                        const savePayload = {
                            last_quoted_products: JSON.stringify(smartResponse.quotedProducts),
                            last_product_discussed: summary || conversation.last_product_discussed,
                            state: 'pricing_inquiry'
                        };

                        console.log('[DIAGNOSTIC] About to save to database:', {
                            conversationId: conversation.id,
                            quotedProducts: smartResponse.quotedProducts,
                            quotedProductsStringified: savePayload.last_quoted_products,
                            productSummary: summary
                        });

                        let updateRes = await supabase
                            .from('conversations')
                            .update(savePayload)
                            .eq('id', conversation.id);

                        if (updateRes.error) {
                            console.warn('[PRICE_SAVE] conversations.update failed:', updateRes.error.message);
                            try {
                                const botMessage = {
                                    conversation_id: conversation.id,
                                    sender: 'bot',
                                    message_body: JSON.stringify({ quotedProducts: smartResponse.quotedProducts, summary }),
                                    message_type: 'quoted_products',
                                    created_at: new Date().toISOString()
                                };
                                const insertMsg = await supabase.from('messages').insert(botMessage).select('id').single();
                                if (!insertMsg.error) {
                                    console.log('[PRICE_SAVE] Fallback: inserted quoted_products message id:', insertMsg.data.id);
                                }
                            } catch (insertErr) {
                                console.error('[PRICE_SAVE] Exception while inserting fallback message:', insertErr?.message);
                            }
                        } else {
                            console.log('[PRICE_SAVE] Saved', smartResponse.quotedProducts.length, 'quoted products for conversation:', conversation.id);
                        }
                    } catch (err) {
                        console.warn('[PRICE_SAVE] Unexpected error while saving quoted products:', err?.message);
                    }
                }

                await sendAndLogMessage(from, smartResponse.response, tenant.id, smartResponse.source);
                return res.status(200).json({ ok: true, type: smartResponse.source });
            } else {
                console.log('[DEBUG_FLOW] Smart Router returned null - continuing to next step');
            }
        } catch (smartError) {
            console.error('[DEBUG_FLOW] ERROR in Smart Response Router:', smartError.message);
        }

        // === GREETING HANDLER ===
        console.log('[DEBUG_FLOW] STEP 1.5: Checking for simple greetings...');
        const greetingPattern = /^(hi|hello|hey|good\s*(morning|afternoon|evening)|namaste|namaskar)[\s!.]*$/i;
        if (greetingPattern.test(userQuery.trim())) {
            console.log('[DEBUG_FLOW] Simple greeting detected - sending friendly response');
            const firstName = customerProfile?.first_name || 'there';
            const greetingResponses = [
                `Hello ${firstName}! ðŸ‘‹\n\nHow can I help you today?`,
                `Hi ${firstName}! ðŸ™‚\n\nWhat can I do for you?`,
                `Hey ${firstName}! ðŸ‘‹\n\nLooking for something specific?`
            ];
            const greeting = greetingResponses[Math.floor(Math.random() * greetingResponses.length)];
            await sendAndLogMessage(from, greeting, tenant.id, 'greeting_response');
            await trackResponse(tenant.id, userQuery, 'rule_based', 0);
            return res.status(200).json({ ok: true, type: 'greeting_response' });
        }

        // === STEP 1.6: DISCOUNT NEGOTIATION (AI-powered) ===
        console.log('[DEBUG_FLOW] STEP 1.6: Checking for discount negotiations...');

        const isDiscountIntent = intentResult?.intent === 'DISCOUNT_REQUEST' ||
                                 (intentResult?.confidence > 0.85 &&
                                  ['discount_request', 'negotiation'].includes(intentResult?.intent?.toLowerCase()));

        if (isDiscountIntent || isDiscountNegotiation(userQuery)) {
            console.log('[DISCOUNT_NEG] Discount negotiation detected');

            // Re-fetch conversation
            const { data: freshConv } = await supabase
                .from('conversations')
                .select('*')
                .eq('tenant_id', tenant.id)
                .eq('end_user_phone', from)
                .single();

            if (!freshConv) {
                console.log('[DISCOUNT_NEG] No conversation found');
            } else {
                conversation = freshConv;

                try {
                    // Build context for negotiation
                    let totalCartons = 0;
                    let cartTotal = 0;
                    let products = [];
                    let isReturningCustomer = false;

                    // Check for previous orders
                    const { data: previousOrders } = await supabase
                        .from('orders')
                        .select('id')
                        .eq('tenant_id', tenant.id)
                        .eq('customer_phone', from)
                        .limit(1);

                    isReturningCustomer = previousOrders && previousOrders.length > 0;

                    // Get quoted products
                    if (conversation.last_quoted_products) {
                        try {
                            const quotedProducts = typeof conversation.last_quoted_products === 'string'
                                ? JSON.parse(conversation.last_quoted_products)
                                : conversation.last_quoted_products;

                            if (quotedProducts && quotedProducts.length > 0) {
                                totalCartons = quotedProducts.reduce((sum, p) => sum + (p.quantity || 0), 0);
                                products = quotedProducts.map(qp => ({
                                    productCode: qp.productCode,
                                    productName: qp.productName,
                                    price: qp.price,
                                    unitsPerCarton: qp.unitsPerCarton || 1500,
                                    quantity: qp.quantity || 10
                                }));
                                cartTotal = products.reduce((sum, p) => sum + (p.price * p.quantity), 0);
                            }
                        } catch (e) {
                            console.warn('[DISCOUNT_NEG] Error parsing quoted products:', e.message);
                        }
                    }

                    const conversationContext = {
                        totalCartons: totalCartons || 10,
                        cartTotal: cartTotal,
                        isReturningCustomer: isReturningCustomer,
                        averagePrice: cartTotal > 0 ? cartTotal / totalCartons : 2400,
                        averageUnitsPerCarton: 1500,
                        products: products,
                        quotedProducts: quotedProducts || []  // Add quotedProducts to context
                    };

                    // Handle discount negotiation
                    const discountResult = await handleDiscountNegotiation(
                        tenant.id,
                        from,
                        userQuery,
                        conversationContext
                    );

                    if (discountResult && discountResult.response) {
                        const discountPercent = discountResult.discountPercent ||
                                               discountResult.offeredDiscount ||
                                               discountResult.counterOffer || 0;

                        // Save discount to conversation
                        if (discountPercent > 0) {
                            console.log('[DISCOUNT_NEG] ðŸ’¾ Saving', discountPercent + '% to context');

                            await supabase
                                .from('conversations')
                                .update({
                                    context_data: {
                                        ...(conversation.context_data || {}),
                                        approvedDiscount: discountPercent,
                                        discountOfferedAt: new Date().toISOString()
                                    }
                                })
                                .eq('id', conversation.id);
                        }

                        await sendAndLogMessage(from, discountResult.response, tenant.id, 'discount_negotiation');
                        return res.status(200).json({ ok: true, type: 'discount_negotiation' });
                    }

                } catch (discountError) {
                    console.error('[DISCOUNT_NEG] Error:', discountError.message);
                }
            }
        }

        // === CRITICAL: PRICE INQUIRY GUARD === 
        // COMMENTED OUT: Let smart router handle all price queries with robust product matching
        /*
        // If the query contains 'price' or 'prices', treat as price inquiry ONLY, do not add to cart/order
        if (/\bprice(s)?\b/i.test(userQuery)) {
            console.log('[PRICE_INQUIRY_GUARD] Query contains "price" or "prices" - treating as price inquiry, not order.');
            let foundAny = false;
            let priceMsg = 'Here are the prices you requested:\n\n';
            // Special handling for 'all nff' or similar broad queries
            if (/all\s+nff/i.test(userQuery) || /prices?\s+for\s+all\s+nff/i.test(userQuery)) {
                // Fetch all products with 'nff' in the name
                const { data: products } = await supabase
                    .from('products')
                    .select('name, price, packaging_unit, units_per_carton')
                    .eq('tenant_id', tenant.id)
                    .ilike('name', '%nff%')
                    .order('name');
                if (products && products.length > 0) {
                    foundAny = true;
                    for (const product of products) {
                        priceMsg += `*${product.name}*: â‚¹${product.price} per ${product.packaging_unit || 'carton'}`;
                        if (product.units_per_carton) priceMsg += ` (${product.units_per_carton} pcs/carton)`;
                        priceMsg += '\n';
                    }
                }
                if (foundAny) {
                    priceMsg += '\nTo order, reply with the product and quantity.';
                    await sendAndLogMessage(from, priceMsg, tenant.id, 'price_inquiry');
                    return res.status(200).json({ ok: true, type: 'price_inquiry' });
                } else {
                    await sendAndLogMessage(from, 'No NFF products found.', tenant.id, 'price_inquiry');
                    return res.status(200).json({ ok: true, type: 'price_inquiry' });
                }
            }
            // ...existing code for specific product price queries...
        }
        */

        // === HIGH-PRIORITY: "EACH N" ORDER HANDLER ===
        // This handler processes "2ctns each" or "each 2 ctns" style orders using conversation context
        console.log('[DEBUG_FLOW] STEP 1.5: Checking for "each N" patterns...');
        
        // CRITICAL: Refresh conversation to get latest quoted products
        console.log('[CONTEXT_REFRESH] Refreshing conversation data to get latest context...');
        const { data: freshConversation } = await supabase
            .from('conversations')
            .select('*')
            .eq('tenant_id', tenant.id)
            .eq('end_user_phone', from)
            .single();
        
        conversationContext = freshConversation || conversation;
        console.log('[CONTEXT_CHECK] Conversation state:', {
            hasConversation: !!conversationContext,
            conversationId: conversationContext?.id,
            hasQuotedProducts: !!conversationContext?.last_quoted_products,
            hasProductDiscussed: !!conversationContext?.last_product_discussed,
            quotedProductsPreview: conversationContext?.last_quoted_products ? 
                (typeof conversationContext.last_quoted_products === 'string' ? 
                    conversationContext.last_quoted_products.substring(0, 100) + '...' : 
                    JSON.stringify(conversationContext.last_quoted_products).substring(0, 100) + '...') 
                : 'none',
            productDiscussed: conversationContext?.last_product_discussed
        });
        try {
            // Enhanced patterns to catch "2ctns each", "2 ctns each", "each 2 ctns", etc.
            const eachMatch = userQuery.match(/\bmujhe\s+each\s+(\d{1,6})\s*(?:ctns?|cartons?)\s+chahiye\b/i) ||
                             userQuery.match(/\b(?:each|har(?:\s*ek)?)\s+(\d{1,6})\s*(?:ctns?|cartons?|pcs|pieces)(?!\s+ki\s+prices?)/i) ||
                             userQuery.match(/(\d{1,6})\s*(?:ctns?|cartons?|pcs?|pieces?)\s+(?:each|per)(?!\s+ki\s+prices?)/i) ||
                             userQuery.match(/(\d{1,6})\s*(?:ctns?|cartons?)\s*(?:each|per)(?!\s+ki\s+prices?)/i) || // NEW: handles "2ctns each"
                             userQuery.match(/har(?:\s*product)?\s*(?:ke)?\s*(\d{1,6})\s*(?:ctns?|cartons?|pcs|pieces)(?!\s+ki\s+prices?)/i);

            console.log('[DEBUG_FLOW] Each pattern test result:', eachMatch ? 'FOUND' : 'NOT_FOUND');
            
            if (eachMatch) {
                console.log('[EACH_ORDER] Detected "each" style order. match:', eachMatch[0]);

                const qty = Number(eachMatch[1] || eachMatch[0].match(/\d+/)?.[0]) || null;
                console.log('[DEBUG_FLOW] Parsed quantity from each pattern:', qty);

                if (qty && qty > 0) {
                    let quoted = null;

                    // Try to get quoted products from conversation (using fresh context)
                    if (conversationContext && conversationContext.last_quoted_products) {
                        try {
                            quoted = typeof conversationContext.last_quoted_products === 'string'
                                ? JSON.parse(conversationContext.last_quoted_products)
                                : conversationContext.last_quoted_products;
                            if (!Array.isArray(quoted) || quoted.length === 0) {
                                quoted = null;
                            } else {
                                console.log('[DEBUG_FLOW] Using last_quoted_products:', quoted?.length || 0, 'products');
                            }
                        } catch (e) {
                            console.warn('[EACH_ORDER] Could not parse conversation.last_quoted_products:', e?.message);
                            quoted = null;
                        }
                    }

                    // Fallback to last_product_discussed
                    if ((!quoted || quoted.length === 0) && conversationContext && conversationContext.last_product_discussed) {
                        const codes = conversationContext.last_product_discussed.split(',').map(s => s.trim()).filter(Boolean);
                        if (codes.length > 0) {
                            quoted = codes.map(code => ({
                                productCode: code,
                                productName: code,
                                quantity: 1,
                                unit: 'cartons'
                            }));
                            console.log('[DEBUG_FLOW] Using last_product_discussed fallback:', quoted?.length || 0, 'products');
                        }
                    }

                    // NEW: Fallback to extracting product codes from current query if no context
                    if ((!quoted || quoted.length === 0)) {
                        // Extract product codes from the user query (e.g., 8x80, 8x100, etc.)
                        const codeRegex = /(nff\s*)?(\d+x\d+)/gi;
                        let match;
                        let codes = [];
                        while ((match = codeRegex.exec(userQuery)) !== null) {
                            let code = (match[1] ? match[1] : '') + match[2];
                            code = code.trim();
                            if (code) codes.push(code);
                        }
                        if (codes.length > 0) {
                            quoted = codes.map(code => ({
                                productCode: code,
                                productName: code,
                                quantity: 1,
                                unit: 'cartons'
                            }));
                            console.log('[DEBUG_FLOW] Using codes extracted from current query:', quoted?.length || 0, 'products');
                        }
                    }

                    if (quoted && Array.isArray(quoted) && quoted.length > 0) {
                        const orders = quoted.map(q => ({
                            productCode: (q.productCode || q.productName || '').toString().trim(),
                            productName: (q.productName || q.productCode || '').toString().trim(),
                            quantity: qty,
                            unit: 'cartons',
                            originalText: `each ${qty}`
                        })).filter(o => o.productCode);

                        console.log('[DEBUG_FLOW] Built orders from each pattern:', orders.map(o => `${o.productCode}:${o.quantity}`).join('; '));

                        if (orders.length > 0) {
                            const orderDetails = {
                                isMultipleProducts: orders.length > 1,
                                orders: orders, // Always use 'orders' for multi-product
                                originalText: userQuery,
                                extractionMethod: 'each_applied_to_quoted_or_query'
                            };

                            console.log('[EACH_ORDER] Built orderDetails from quoted products or query:', orders.map(o => `${o.productCode}:${o.quantity}`).join('; '));
                            console.log('[DEBUG_FLOW] EACH PATTERN PROCESSED - calling order processing');

                            return await handleOrderRequest(tenant, from, orderDetails, conversation, res);
                        }
                    } else {
                        console.log('[EACH_ORDER] No quoted products or codes found to apply "each" qty to.');
                    }
                }
            }
        } catch (err) {
            console.warn('[EACH_ORDER] Unexpected error:', err?.message);
        }

        // === AI-POWERED: ADDITIONAL PRODUCT REQUEST (in order_discussion state) ===
        console.log('[DEBUG_FLOW] STEP 2A: Checking Additional Product Request (AI-powered)...');
        console.log('[DEBUG_FLOW] Current conversation state:', conversation?.state);
        console.log('[DEBUG_FLOW] Intent result:', intentResult?.intent);
        
        // Check if in a state where products are being discussed
        const isInProductDiscussion = conversation?.state === 'order_discussion' || 
                                     conversation?.state === 'multi_product_order_discussion' ||
                                     conversation?.state === 'pricing_inquiry' ||
                                     (conversation?.last_product_discussed && intentResult?.intent === 'ADD_PRODUCT');
        
        if (isInProductDiscussion) {
            // Use AI intent recognition (already computed above at line ~1448)
            // Or do quick classification with context
            const IntentClassifier = require('../../services/ai/intentClassifier');
            const quickIntent = IntentClassifier.quickClassify(userQuery, {
                inOrderDiscussion: true,
                conversationState: conversation.state
            });
            
            console.log('[ADDITIONAL_PRODUCT] Quick intent check:', quickIntent.intent, 'confidence:', quickIntent.confidence);
            
            // Check if intent is ADD_PRODUCT (from AI or intentResult)
            const isAddingProduct = intentResult?.intent === 'ADD_PRODUCT' || quickIntent.intent === 'ADD_PRODUCT';
            
            if (isAddingProduct) {
                console.log('[ADDITIONAL_PRODUCT] AI detected ADD_PRODUCT intent - extracting details...');
                
                // Use AI to extract order details (handles typos, natural language, Hindi)
                // Correct parameter order: extractOrderDetails(userQuery, tenantId)
                const extractionResult = await extractOrderDetails(userQuery, tenant.id);
                
                console.log('[ADDITIONAL_PRODUCT] Extraction result:', extractionResult ? JSON.stringify(extractionResult) : 'null');
                
                // **DEBUG: Unit detection validation**
                if (extractionResult) {
                    console.log('[UNIT_DEBUG] Original query:', userQuery);
                    console.log('[UNIT_DEBUG] Detected unit:', extractionResult.unit || 'undefined');
                    console.log('[UNIT_DEBUG] Is pieces:', extractionResult.isPieces || false);
                    if (extractionResult.orders) {
                        extractionResult.orders.forEach((order, idx) => {
                            console.log(`[UNIT_DEBUG] Order ${idx + 1}:`, order.productCode, 'Qty:', order.quantity, 'Unit:', order.unit, 'IsPieces:', order.isPieces);
                        });
                    }
                }
                
                // extractOrderDetails returns: { productCode, productName, quantity, unit, ... }
                // OR for multi-product: { isMultipleProducts: true, orders: [...] }
                if (extractionResult && (extractionResult.productCode || (extractionResult.orders && extractionResult.orders.length > 0))) {
                    // Handle single product or first product from multi-product extraction
                    const newProduct = extractionResult.productCode ? extractionResult : extractionResult.orders[0];
                    const productCode = newProduct.productCode;
                    const quantity = newProduct.quantity;
                    const unit = newProduct.unit;
                    
                    console.log('[ADDITIONAL_PRODUCT] AI extracted:', { productCode, quantity, unit });
                    
                    // Check if it's a DIFFERENT product from last discussed
                    const lastProductCode = conversation.last_product_discussed?.match(/\d+[x*]\d+/i)?.[0]?.toLowerCase();
                    const newProductCode = productCode.toLowerCase().replace('*', 'x');
                    const lastCodeNormalized = lastProductCode?.replace('*', 'x');
                    
                    if (newProductCode !== lastCodeNormalized) {
                        console.log('[ADDITIONAL_PRODUCT] Adding NEW product to existing order (AI-powered)');
                        console.log(`[ADDITIONAL_PRODUCT] Last: ${lastCodeNormalized}, New: ${newProductCode}`);
                        
                        // FIRST: If there are quoted products, add them to cart
                        // Parse last_quoted_products (it's stored as JSON string)
                        let quotedProducts = [];
                        if (conversation.last_quoted_products) {
                            try {
                                quotedProducts = JSON.parse(conversation.last_quoted_products);
                                console.log('[ADDITIONAL_PRODUCT] Found quoted products:', quotedProducts.length);
                            } catch (e) {
                                console.error('[ADDITIONAL_PRODUCT] Failed to parse quoted products:', e.message);
                            }
                        }
                        
                        if (quotedProducts && quotedProducts.length > 0) {
                            console.log('[ADDITIONAL_PRODUCT] Adding quoted products to cart first');
                            for (const quotedProduct of quotedProducts) {
                                const quotedOrderDetails = {
                                    productCode: quotedProduct.productCode,
                                    productName: quotedProduct.productName,
                                    quantity: quotedProduct.quantity,
                                    unit: quotedProduct.unit || 'cartons',
                                    isPieces: false,
                                    isAdditionalProduct: true, // Don't clear cart
                                    originalText: `quoted: ${quotedProduct.productCode} ${quotedProduct.quantity}`
                                };
                                await processOrderRequestEnhanced(tenant.id, from, quotedOrderDetails);
                                console.log('[ADDITIONAL_PRODUCT] Added quoted product to cart:', quotedProduct.productCode);
                            }
                        }
                        
                        // THEN: Add the new product
                        const newOrderDetails = {
                            productCode: productCode,
                            productName: newProduct.productName || productCode,
                            quantity: quantity,
                            unit: unit,
                            isPieces: unit.toLowerCase().includes('piece'),
                            isAdditionalProduct: true, // KEY FLAG: Don't clear cart
                            originalText: userQuery
                        };
                        
                        // Process new product (DON'T clear cart)
                        const result = await processOrderRequestEnhanced(tenant.id, from, newOrderDetails);
                        
                        if (result.success) {
                            await sendAndLogMessage(from, result.message, tenant.id, 'additional_product_added');
                            
                            // Update conversation to track multiple products
                            const allProducts = [conversation.last_product_discussed, productCode].filter(Boolean).join(', ');
                            await supabase
                                .from('conversations')
                                .update({ 
                                    state: 'multi_product_order_discussion',
                                    last_product_discussed: allProducts
                                })
                                .eq('id', conversation.id);
                            
                            // Show updated cart with all products
                            const cartView = await viewCartWithDiscounts(tenant.id, from);
                            const confirmMsg = cartView + '\n\n' +
                                'Ready to place order? Reply "yes go ahead" to checkout.';
                            
                            await sendAndLogMessage(from, confirmMsg, tenant.id, 'cart_with_multiple_products');
                            
                            return res.status(200).json({ ok: true, type: 'additional_product_added' });
                        } else {
                            await sendAndLogMessage(from, result.message, tenant.id, 'additional_product_error');
                            return res.status(200).json({ ok: true, type: 'additional_product_error' });
                        }
                    } else {
                        console.log('[ADDITIONAL_PRODUCT] Same product - treating as quantity update');
                        // Fall through to existing quantity change detection
                    }
                } else {
                    console.log('[ADDITIONAL_PRODUCT] AI extraction failed or no products found');
                    // Fall through to other handlers
                }
            }
        }

        // === NEW: ENHANCED COMBINED ORDER PROCESSING ===
        console.log('[DEBUG_FLOW] STEP 2B: Enhanced Combined Order Processing...');
        
        // Check for combined product+quantity patterns first
        const combinedOrderDetails = await extractCombinedOrderDetails(userQuery, tenant.id);
        
        if (combinedOrderDetails && combinedOrderDetails.success) {
            console.log('[DEBUG_FLOW] Combined order extraction successful');
            console.log('[COMBINED_ORDER] Found combined pattern, processing order...');
            
            return await handleOrderRequest(tenant, from, combinedOrderDetails, conversation, res);
        } else {
            console.log('[DEBUG_FLOW] No combined patterns found, continuing to existing order processing...');
        }

        // === ENHANCED ORDER CONFIRMATION CHECK (PRESERVED) ===
        console.log('[DEBUG_FLOW] STEP 2: Checking Order Confirmation...');
        console.log('[ORDER_CONFIRM] User query:', userQuery);
        console.log('[ORDER_CONFIRM] Intent result:', JSON.stringify(intentResult, null, 2));
        console.log('[ORDER_CONFIRM] Conversation state:', conversation?.state);
        console.log('[ORDER_CONFIRM] Conversation context_data:', conversation?.context_data);
        
        // Use AI intent OR traditional pattern matching
        const isOrderConfirmation = (intentResult.intent === 'ORDER_CONFIRMATION' && intentResult.confidence > 0.7) ||
                                    await isOrderConfirmationEnhanced(userQuery, conversation, tenant.id);
        
        console.log('[ORDER_CONFIRM] isOrderConfirmation:', isOrderConfirmation);
        
        if (conversation && isOrderConfirmation) {
            console.log('[DEBUG_FLOW] ORDER CONFIRMATION detected via', 
                intentResult.intent === 'ORDER_CONFIRMATION' ? 'AI intent' : 'pattern matching');
            
            // CRITICAL: Check if user is confirming a pending discount offer
            if (conversation.state === 'discount_offered' && conversation.context_data) {
                try {
                    const contextData = safeParseContextData(conversation.context_data);
                    if (contextData.offeredDiscount && contextData.offeredDiscount > 0) {
                        console.log('[DISCOUNT_NEG] User confirmed offered discount:', contextData.offeredDiscount + '%');
                        
                        // Convert offered discount to approved discount
                        // NOTE: We do NOT update last_quoted_products prices here
                        // The cart discount system will apply the discount at checkout
                        await supabase
                            .from('conversations')
                            .update({
                                state: 'discount_approved',
                                context_data: JSON.stringify({
                                    approvedDiscount: contextData.offeredDiscount,
                                    discountTimestamp: new Date().toISOString()
                                })
                            })
                            .eq('id', conversation.id);
                        
                        // Update local conversation object
                        conversation.state = 'discount_approved';
                        conversation.context_data = JSON.stringify({
                            approvedDiscount: contextData.offeredDiscount,
                            discountTimestamp: new Date().toISOString()
                        });
                        
                        console.log('[DISCOUNT_NEG] Discount approved and saved:', contextData.offeredDiscount + '%');
                        // Ensure per-item discount is applied before checkout
                        const { applyApprovedDiscountToCart } = require('../../services/cartService');
                        await applyApprovedDiscountToCart(tenant.id, from);
                    }
                } catch (metadataError) {
                    console.warn('[DISCOUNT_NEG] Error parsing offered discount context_data:', metadataError.message);
                }
            }
            
            // Check if cart has items before proceeding
            const { data: cart } = await supabase
                .from('carts')
                .select(`
                    id,
                    discount_amount,
                    cart_items (
                        quantity,
                        product:products (name, price)
                    )
                `)
                .eq('conversation_id', conversation.id)
                .single();

            console.log('[DEBUG_FLOW] Cart query result:', cart ? 'FOUND' : 'NOT_FOUND');
            console.log('[DEBUG_FLOW] Cart items count:', cart?.cart_items?.length || 0);

            if (cart && cart.cart_items && cart.cart_items.length > 0) {
                console.log('[DEBUG_FLOW] Cart has items - proceeding with checkout');

                // âœ… CRITICAL: Check for pending discount in conversation context FIRST
                console.log('[DISCOUNT_APPLICATION] Checking for pending discount before checkout');

                const { data: freshConv } = await supabase
                    .from('conversations')
                    .select('context_data')
                    .eq('id', conversation.id)
                    .single();

                if (freshConv?.context_data?.pendingDiscount) {
                    const pendingDiscount = freshConv.context_data.pendingDiscount;
                    const discountPercent = pendingDiscount.percent;

                    console.log('[DISCOUNT_APPLICATION] ðŸŽ¯ Found pending discount:', discountPercent + '%');

                    // Apply discount to all cart items
                    const { data: cartWithItems } = await supabase
                        .from('carts')
                        .select(`
                            id,
                            cart_items (
                                id,
                                product_id,
                                quantity,
                                products (price, units_per_carton)
                            )
                        `)
                        .eq('conversation_id', conversation.id)
                        .single();

                    if (cartWithItems && cartWithItems.cart_items && cartWithItems.cart_items.length > 0) {
                        for (const item of cartWithItems.cart_items) {
                            // Get personalized price first
                            const personalizedPricing = await formatPersonalizedPriceDisplay(
                                tenant.id,
                                from,
                                item.product_id
                            );

                            const basePrice = personalizedPricing?.pricePerCarton || item.products.price;
                            const discountedPrice = basePrice * (1 - discountPercent / 100);
                            const discountAmount = basePrice - discountedPrice;

                            console.log('[DISCOUNT_APPLICATION] Applying to product:', {
                                productId: item.product_id,
                                basePrice: basePrice,
                                discountPercent: discountPercent,
                                discountedPrice: discountedPrice.toFixed(2),
                                savingsPerCarton: discountAmount.toFixed(2)
                            });

                            // Update cart item with negotiated discount
                            await supabase
                                .from('cart_items')
                                .update({
                                    carton_price_override: discountedPrice,
                                    carton_discount_amount: discountAmount,
                                    updated_at: new Date().toISOString()
                                })
                                .eq('id', item.id);
                        }

                        console.log('[DISCOUNT_APPLICATION] âœ… Negotiated discount applied to all cart items');

                        // Clear pending discount from context and mark as applied
                        const currentContextData = safeParseContextData(freshConv.context_data);
                        const updatedContextData = {
                            ...currentContextData,
                            pendingDiscount: null,
                            appliedDiscount: {
                                percent: discountPercent,
                                appliedAt: new Date().toISOString()
                            }
                        };

                        await supabase
                            .from('conversations')
                            .update({
                                context_data: JSON.stringify(updatedContextData)
                            })
                            .eq('id', conversation.id);
                    }
                } else {
                    console.log('[DISCOUNT_APPLICATION] No pending discount found');
                }

                // Check if there's an approved discount that needs to be applied
                if (conversation.state === 'discount_approved' && conversation.context_data) {
                    try {
                        const contextData = safeParseContextData(conversation.context_data);
                        if (contextData.offeredDiscount && contextData.offeredDiscount > 0) {
                            console.log('[DISCOUNT_NEG] Applying approved discount to cart:', contextData.offeredDiscount + '%');
                            
                            // Calculate discount amount based on cart total
                            const cartTotal = cart.cart_items.reduce((sum, item) => {
                                return sum + (item.product.price * item.quantity);
                            }, 0);
                            
                            const discountAmount = (cartTotal * contextData.offeredDiscount) / 100;
                            
                            // Update cart with discount
                            await supabase
                                .from('carts')
                                .update({
                                    discount_amount: discountAmount
                                })
                                .eq('id', cart.id);
                            
                            console.log('[DISCOUNT_NEG] Cart updated with discount amount:', discountAmount);
                        }
                    } catch (metadataError) {
                        console.warn('[DISCOUNT_NEG] Error parsing conversation context_data:', metadataError.message);
                    }
                }
                
                // === CRITICAL: Check if GST collection is needed before checkout ===
                const customerProfile = await getCustomerProfile(tenant.id, from);
                
                // Debug logging
                console.log('[CHECKOUT_GUARD] Customer profile fetched:', {
                    hasProfile: !!customerProfile,
                    gst_number: customerProfile?.gst_number || 'MISSING',
                    onboarding_completed: customerProfile?.onboarding_completed || false,
                    business_verified: customerProfile?.business_verified || false
                });
                
                // CRITICAL FIX: If customer has GST but flags are false, auto-fix the flags
                if (customerProfile && customerProfile.gst_number && !customerProfile.onboarding_completed) {
                    console.log('[CHECKOUT_GUARD] Auto-fixing flags for customer with GST:', customerProfile.gst_number);
                    
                    try {
                        await supabase
                            .from('customer_profiles')
                            .update({
                                onboarding_completed: true,
                                business_verified: true
                            })
                            .eq('id', customerProfile.id);
                        
                        // Update local object
                        customerProfile.onboarding_completed = true;
                        customerProfile.business_verified = true;
                        console.log('[CHECKOUT_GUARD] âœ… Flags updated successfully');
                    } catch (flagError) {
                        console.error('[CHECKOUT_GUARD] Failed to update flags:', flagError.message);
                    }
                }
                
                // Check if customer needs to provide GST details (for business customers)
                if (!customerProfile || !customerProfile.gst_number || !customerProfile.onboarding_completed) {
                    console.log('[CHECKOUT_GUARD] Customer missing GST - requesting business info');
                    console.log('[CHECKOUT_GUARD] Reason:', {
                        noProfile: !customerProfile,
                        noGST: !customerProfile?.gst_number,
                        notOnboarded: !customerProfile?.onboarding_completed
                    });
                    
                    // Update conversation state to collect GST
                    await supabase
                        .from('conversations')
                        .update({
                            state: 'awaiting_gst_info',
                            context_data: JSON.stringify({
                                pendingCheckout: true,
                                cartId: cart.id,
                                approvedDiscount: conversation.context_data ? safeParseContextData(conversation.context_data).approvedDiscount : null
                            })
                        })
                        .eq('id', conversation.id);
                    
                    const gstRequestMessage = `ðŸ“‹ *Before we proceed with your order*\n\n` +
                        `To generate a proper GST invoice and sales order, I'll need:\n\n` +
                        `1ï¸âƒ£ Your GST Number (if registered)\n` +
                        `2ï¸âƒ£ Company/Business Name\n` +
                        `3ï¸âƒ£ Complete Business Address\n\n` +
                        `You can either:\n` +
                        `â€¢ Type the details in your next message\n` +
                        `â€¢ Upload your GST Certificate (PDF/Image)\n` +
                        `â€¢ Type "skip" if you want to proceed without GST (consumer billing)\n\n` +
                        `ðŸ’¡ *Tip: GST registration helps you claim input tax credit!*`;
                    
                    await sendAndLogMessage(from, gstRequestMessage, tenant.id, 'gst_collection_request');
                    return res.status(200).json({ ok: true, type: 'gst_collection_requested' });
                }
                
                const result = await checkoutWithDiscounts(tenant, from);
                await sendAndLogMessage(from, result, tenant.id, 'checkout_confirmed');
                
                if (tenant.payment_qr_code_url) {
                    try {
                        const qrMessage = "QR code available for payment. Please contact us for the QR code image.";
                        await sendAndLogMessage(from, qrMessage, tenant.id, 'qr_code_available');
                    } catch (qrError) {
                        console.warn('Failed to send QR code message:', qrError.message);
                    }
                }
                
                await supabase
                    .from('conversations')
                    .update({ 
                        state: null,
                        last_product_discussed: null
                    })
                    .eq('id', conversation.id);
                    
                console.log('[DEBUG_FLOW] Checkout completed successfully');
                return res.status(200).json({ ok: true, type: 'order_confirmed' });
            } else {
                console.log('[DEBUG_FLOW] Cart is empty - attempting auto-add');
                
                const { data: refreshedConversation } = await supabase
                    .from('conversations')
                    .select('*')
                    .eq('id', conversation.id)
                    .single();

                const autoAddResult = await autoAddDiscussedProductToCart(tenant.id, from, refreshedConversation || conversation);
                
                if (autoAddResult.success && !autoAddResult.skipAutoAdd) {
                    console.log('[DEBUG_FLOW] Auto-add successful - proceeding with checkout');

                    // âœ… CRITICAL: Apply pending discount after auto-add
                    console.log('[DISCOUNT_APPLICATION] Checking for pending discount after auto-add');

                    const { data: freshConvAfterAutoAdd } = await supabase
                        .from('conversations')
                        .select('context_data')
                        .eq('id', conversation.id)
                        .single();

                    if (freshConvAfterAutoAdd?.context_data?.pendingDiscount) {
                        const pendingDiscount = freshConvAfterAutoAdd.context_data.pendingDiscount;
                        const discountPercent = pendingDiscount.percent;

                        console.log('[DISCOUNT_APPLICATION] ðŸŽ¯ Applying pending discount after auto-add:', discountPercent + '%');

                        // Get the cart that was just populated by auto-add
                        const { data: cartAfterAutoAdd } = await supabase
                            .from('carts')
                            .select(`
                                id,
                                cart_items (
                                    id,
                                    product_id,
                                    quantity,
                                    products (price, units_per_carton)
                                )
                            `)
                            .eq('conversation_id', conversation.id)
                            .single();

                        if (cartAfterAutoAdd && cartAfterAutoAdd.cart_items && cartAfterAutoAdd.cart_items.length > 0) {
                            for (const item of cartAfterAutoAdd.cart_items) {
                                // Get personalized price first
                                const personalizedPricing = await formatPersonalizedPriceDisplay(
                                    tenant.id,
                                    from,
                                    item.product_id
                                );

                                const basePrice = personalizedPricing?.pricePerCarton || item.products.price;
                                const discountedPrice = basePrice * (1 - discountPercent / 100);
                                const discountAmount = basePrice - discountedPrice;

                                console.log('[DISCOUNT_APPLICATION] Applying to auto-added product:', {
                                    productId: item.product_id,
                                    basePrice: basePrice,
                                    discountPercent: discountPercent,
                                    discountedPrice: discountedPrice.toFixed(2),
                                    savingsPerCarton: discountAmount.toFixed(2)
                                });

                                // Update cart item with negotiated discount
                                await supabase
                                    .from('cart_items')
                                    .update({
                                        carton_price_override: discountedPrice,
                                        carton_discount_amount: discountAmount,
                                        updated_at: new Date().toISOString()
                                    })
                                    .eq('id', item.id);
                            }

                            console.log('[DISCOUNT_APPLICATION] âœ… Negotiated discount applied to auto-added cart items');

                            // Clear pending discount from context and mark as applied
                            const currentContextData = safeParseContextData(freshConvAfterAutoAdd.context_data);
                            const updatedContextData = {
                                ...currentContextData,
                                pendingDiscount: null,
                                appliedDiscount: {
                                    percent: discountPercent,
                                    appliedAt: new Date().toISOString()
                                }
                            };

                            await supabase
                                .from('conversations')
                                .update({
                                    context_data: JSON.stringify(updatedContextData)
                                })
                                .eq('id', conversation.id);
                        }
                    } else {
                        console.log('[DISCOUNT_APPLICATION] No pending discount found after auto-add');
                    }

                    // Check if there's an approved discount that needs to be applied
                    if (conversation.state === 'discount_approved' && conversation.context_data) {
                        try {
                            const contextData = safeParseContextData(conversation.context_data);
                            if (contextData.offeredDiscount && contextData.offeredDiscount > 0) {
                                console.log('[DISCOUNT_NEG] Applying approved discount after auto-add:', contextData.offeredDiscount + '%');
                                
                                // Get the cart that was just populated by auto-add
                                const { data: cartAfterAutoAdd } = await supabase
                                    .from('carts')
                                    .select(`
                                        id,
                                        cart_items (
                                            quantity,
                                            product:products (price)
                                        )
                                    `)
                                    .eq('conversation_id', conversation.id)
                                    .single();
                                
                                if (cartAfterAutoAdd && cartAfterAutoAdd.cart_items && cartAfterAutoAdd.cart_items.length > 0) {
                                    // Calculate discount amount based on cart total
                                    const cartTotal = cartAfterAutoAdd.cart_items.reduce((sum, item) => {
                                        return sum + (item.product.price * item.quantity);
                                    }, 0);
                                    
                                    const discountAmount = (cartTotal * contextData.offeredDiscount) / 100;
                                    
                                    // Update cart with discount
                                    await supabase
                                        .from('carts')
                                        .update({
                                            discount_amount: discountAmount
                                        })
                                        .eq('id', cartAfterAutoAdd.id);
                                    
                                    console.log('[DISCOUNT_NEG] Cart updated with discount amount after auto-add:', discountAmount);
                                }
                            }
                        } catch (contextDataError) {
                            console.warn('[DISCOUNT_NEG] Error parsing conversation context_data after auto-add:', contextDataError.message);
                        }
                    }
                    
                    // === CRITICAL: Check if GST collection is needed before emergency checkout ===
                    const customerProfile = await getCustomerProfile(tenant.id, from);
                    
                    // Debug logging
                    console.log('[EMERGENCY_CHECKOUT_GUARD] Customer profile fetched:', {
                        hasProfile: !!customerProfile,
                        gst_number: customerProfile?.gst_number || 'MISSING',
                        onboarding_completed: customerProfile?.onboarding_completed || false,
                        business_verified: customerProfile?.business_verified || false
                    });
                    
                    // CRITICAL FIX: If customer has GST but flags are false, auto-fix the flags
                    if (customerProfile && customerProfile.gst_number && !customerProfile.onboarding_completed) {
                        console.log('[EMERGENCY_CHECKOUT_GUARD] Auto-fixing flags for customer with GST:', customerProfile.gst_number);
                        
                        try {
                            await supabase
                                .from('customer_profiles')
                                .update({
                                    onboarding_completed: true,
                                    business_verified: true
                                })
                                .eq('id', customerProfile.id);
                            
                            // Update local object
                            customerProfile.onboarding_completed = true;
                            customerProfile.business_verified = true;
                            console.log('[EMERGENCY_CHECKOUT_GUARD] âœ… Flags updated successfully');
                        } catch (flagError) {
                            console.error('[EMERGENCY_CHECKOUT_GUARD] Failed to update flags:', flagError.message);
                        }
                    }
                    
                    // Check if customer needs to provide GST details (for business customers)
                    if (!customerProfile || !customerProfile.gst_number || !customerProfile.onboarding_completed) {
                        console.log('[EMERGENCY_CHECKOUT_GUARD] Customer missing GST - requesting business info');
                        console.log('[EMERGENCY_CHECKOUT_GUARD] Reason:', {
                            noProfile: !customerProfile,
                            noGST: !customerProfile?.gst_number,
                            notOnboarded: !customerProfile?.onboarding_completed
                        });
                        
                        // Get the cart to save in context
                        const { data: currentCart } = await supabase
                            .from('carts')
                            .select('id')
                            .eq('conversation_id', conversation.id)
                            .single();
                        
                        // Update conversation state to collect GST
                        await supabase
                            .from('conversations')
                            .update({
                                state: 'awaiting_gst_info',
                                context_data: JSON.stringify({
                                    pendingCheckout: true,
                                    cartId: currentCart?.id,
                                    emergencyCheckout: true,
                                    autoAddedProducts: autoAddResult.productsAdded
                                })
                            })
                            .eq('id', conversation.id);
                        
                        const gstRequestMessage = `ðŸ“‹ *Before we proceed with your order*\n\n` +
                            `To generate a proper GST invoice and sales order, I'll need:\n\n` +
                            `1ï¸âƒ£ Your GST Number (if registered)\n` +
                            `2ï¸âƒ£ Company/Business Name\n` +
                            `3ï¸âƒ£ Complete Business Address\n\n` +
                            `You can either:\n` +
                            `â€¢ Type the details in your next message\n` +
                            `â€¢ Upload your GST Certificate (PDF/Image)\n` +
                            `â€¢ Type "skip" if you want to proceed without GST (consumer billing)\n\n` +
                            `ðŸ’¡ *Tip: GST registration helps you claim input tax credit!*`;
                        
                        await sendAndLogMessage(from, gstRequestMessage, tenant.id, 'gst_collection_request');
                        return res.status(200).json({ ok: true, type: 'gst_collection_requested' });
                    }
                    
                    const result = await checkoutWithDiscounts(tenant, from);
                    
                    let productInfo = 'items';
                    if (autoAddResult.productsAdded && autoAddResult.productsAdded.length > 0) {
                        productInfo = autoAddResult.productsAdded.map(p => p.name).join(', ');
                    }
                    
                    await sendAndLogMessage(from, 
                        `âœ… Added ${productInfo} to cart!\n\n${result}`, 
                        tenant.id, 'emergency_checkout_success');

                    if (tenant.payment_qr_code_url) {
                        try {
                            const qrMessage = "QR code available for payment. Please contact us for the QR code image.";
                            await sendAndLogMessage(from, qrMessage, tenant.id, 'qr_code_available');
                        } catch (qrError) {
                            console.warn('Failed to send QR code message:', qrError.message);
                        }
                    }

                    console.log('[DEBUG_FLOW] Emergency checkout completed successfully');
                    return res.status(200).json({ ok: true, type: 'emergency_fix_success' });
                } else {
                    console.log('[DEBUG_FLOW] Auto-add failed or skipped - sending empty cart message');
                    
                    await sendAndLogMessage(from, 
                        'Your cart is empty. Please specify which products you want to order.',
                        tenant.id, 'empty_cart_checkout');
                    return res.status(200).json({ ok: true, type: 'empty_cart_checkout' });
                }
            }
        }

        // === ENHANCED AI-POWERED ORDER PROCESSING (PRESERVED) ===
        console.log('[DEBUG_FLOW] STEP 3: Order Processing...');

        const orderDetails = await extractOrderDetails(userQuery, tenant.id);
        console.log('[DEBUG_FLOW] Order extraction result:', {
            found: !!orderDetails,
            extractionMethod: orderDetails?.extractionMethod
        });
        
        // **DEBUG: Unit detection validation**
        if (orderDetails) {
            console.log('[UNIT_DEBUG] Original query:', userQuery);
            console.log('[UNIT_DEBUG] Detected unit:', orderDetails.unit || 'undefined');
            console.log('[UNIT_DEBUG] Is pieces:', orderDetails.isPieces || false);
            if (orderDetails.orders) {
                orderDetails.orders.forEach((order, idx) => {
                    console.log(`[UNIT_DEBUG] Order ${idx + 1}:`, order.productCode, 'Qty:', order.quantity, 'Unit:', order.unit, 'IsPieces:', order.isPieces);
                });
            }
        }
        
        if (orderDetails) {
            console.log('[DEBUG_FLOW] Smart extraction successful - processing order');
            return await handleOrderRequest(tenant, from, orderDetails, conversation, res);
        }

        // === QUANTITY CHANGE DETECTION (PRESERVED) ===
        console.log('[DEBUG_FLOW] STEP 4: Core Order Processing (quantity changes)...');
        
        const quantityChange = detectQuantityChange(userQuery);
        
        if (quantityChange.detected) {
            console.log('[DEBUG_FLOW] Quantity change detected - updating cart');
            const updateResult = await updateCartQuantity(tenant.id, from, quantityChange.newQuantity);
            
            if (updateResult.success) {
                await sendAndLogMessage(from, updateResult.message, tenant.id, 'quantity_updated');
                
                const cartView = await viewCartWithDiscounts(tenant.id, from);
                const confirmMsg = cartView + '\n\nReady to place order? Reply "yes go ahead" to checkout.';
                await sendAndLogMessage(from, confirmMsg, tenant.id, 'cart_updated');
                
                return res.status(200).json({ ok: true, type: 'quantity_changed' });
            }
        }

        // === E-COMMERCE COMMANDS (PRESERVED) ===
        console.log('[DEBUG_FLOW] STEP 5: E-commerce Commands...');
        
        if (userQuery.toLowerCase().startsWith('/add_to_cart ')) {
            const productName = userQuery.substring('/add_to_cart '.length).trim();
            const result = await addProductToCart(tenant.id, from, productName);
            await sendAndLogMessage(from, result, tenant.id, 'cart_update');
            return res.status(200).json({ ok: true, type: 'cart_add' });
        }

        if (userQuery.toLowerCase().trim() === '/view_cart') {
            const result = await viewCartWithDiscounts(tenant.id, from);
            await sendAndLogMessage(from, result, tenant.id, 'cart_view');
            return res.status(200).json({ ok: true, type: 'cart_view' });
        }

        if (userQuery.toLowerCase().trim() === '/clearcart') {
            const result = await clearCart(tenant.id, from);
            await sendAndLogMessage(from, result, tenant.id, 'cart_update');
            return res.status(200).json({ ok: true, type: 'cart_clear' });
        }

        if (userQuery.toLowerCase().trim() === '/checkout') {
            const result = await checkoutWithDiscounts(tenant, from);
            await sendAndLogMessage(from, result, tenant.id, 'checkout');
            
            if (tenant.payment_qr_code_url) {
                try {
                    const qrMessage = "QR code available for payment. Please contact us for the QR code image.";
                    await sendAndLogMessage(from, qrMessage, tenant.id, 'qr_code_available');
                } catch (qrError) {
                    console.warn('Failed to send QR code message:', qrError.message);
                }
            }
            
            return res.status(200).json({ ok: true, type: 'checkout' });
        }

        if (userQuery.toLowerCase().trim() === '/order_status') {
            const result = await getOrderStatus(tenant.id, from);
            await sendAndLogMessage(from, result, tenant.id, 'order_status_check');
            return res.status(200).json({ ok: true, type: 'order_status' });
        }

        // Discount Commands (PRESERVED)
        if (userQuery.toLowerCase().startsWith('/apply_discount ') || 
            userQuery.toLowerCase().startsWith('/use_coupon ')) {
            const discountCode = userQuery.split(' ')[1];
            if (!discountCode) {
                await sendAndLogMessage(from, 
                    'Please provide a discount code.\nUsage: /apply_discount CODE', 
                    tenant.id, 'discount_help');
                return res.status(200).json({ ok: true, type: 'discount_help' });
            }
            
            const result = await applyDiscount(tenant.id, from, discountCode);
            await sendAndLogMessage(from, result.message, tenant.id, 'discount_applied');
            return res.status(200).json({ ok: true, type: 'discount_applied' });
        }

        if (userQuery.toLowerCase().trim() === '/remove_discount') {
            const result = await removeDiscount(tenant.id, from);
            await sendAndLogMessage(from, result.message, tenant.id, 'discount_removed');
            return res.status(200).json({ ok: true, type: 'discount_removed' });
        }

        // Carton-Aware Cart Commands (PRESERVED)
        if (userQuery.toLowerCase().startsWith('/add_carton ')) {
            const parts = userQuery.substring('/add_carton '.length).trim().split(' ');
            const quantity = parseInt(parts[0]) || 1;
            const productName = parts.slice(1).join(' ');
            
            if (!productName) {
                await sendAndLogMessage(from, 'Usage: /add_carton <quantity> <product_name>', tenant.id, 'cart_help');
                return res.status(200).json({ ok: true, type: 'cart_help' });
            }
            
            const result = await addCartonProductToCart(tenant.id, from, productName, quantity);
            await sendAndLogMessage(from, result, tenant.id, 'carton_cart_update');
            return res.status(200).json({ ok: true, type: 'carton_cart_add' });
        }

        if (userQuery.toLowerCase().trim() === '/view_carton_cart') {
            const result = await viewCartonCart(tenant.id, from);
            await sendAndLogMessage(from, result, tenant.id, 'carton_cart_view');
            return res.status(200).json({ ok: true, type: 'carton_cart_view' });
        }

        // Enhanced Product Search Commands (PRESERVED)
        if (userQuery.toLowerCase().startsWith('/search_products ')) {
            const searchTerm = userQuery.substring('/search_products '.length).trim();
            if (!searchTerm) {
                await sendAndLogMessage(from, 'Usage: /search_products <search_term>', tenant.id, 'search_help');
                return res.status(200).json({ ok: true, type: 'search_help' });
            }

            try {
                const results = await searchProductsAndVariants(tenant.id, searchTerm, 10);
                
                if (results.length === 0) {
                    await sendAndLogMessage(from, `No products found for "${searchTerm}".`, tenant.id, 'search_no_results');
                    return res.status(200).json({ ok: true, type: 'search_no_results' });
                }

                let message = `ðŸ” **Search Results for "${searchTerm}":**\n\n`;
                results.forEach((product, index) => {
                    message += `${index + 1}. ${formatProductDisplay(product)}\n`;
                    message += '---\n';
                });

                await sendAndLogMessage(from, message, tenant.id, 'search_results');
                return res.status(200).json({ ok: true, type: 'search_results' });
            } catch (error) {
                console.error('Error in product search:', error.message);
                await sendAndLogMessage(from, 'An error occurred while searching products.', tenant.id, 'search_error');
                return res.status(200).json({ ok: true, type: 'search_error' });
            }
        }

        if (userQuery.toLowerCase().startsWith('/product_details ')) {
            const productName = userQuery.substring('/product_details '.length).trim();
            if (!productName) {
                await sendAndLogMessage(from, 'Usage: /product_details <product_name>', tenant.id, 'details_help');
                return res.status(200).json({ ok: true, type: 'details_help' });
            }

            try {
                const product = await findProductOrVariant(tenant.id, productName);
                
                if (!product) {
                    await sendAndLogMessage(from, `Product "${productName}" not found.`, tenant.id, 'details_not_found');
                    return res.status(200).json({ ok: true, type: 'details_not_found' });
                }

                const display = formatProductDisplay(product);
                await sendAndLogMessage(from, display, tenant.id, 'product_details');
                return res.status(200).json({ ok: true, type: 'product_details' });
            } catch (error) {
                console.error('Error getting product details:', error.message);
                await sendAndLogMessage(from, 'An error occurred while fetching product details.', tenant.id, 'details_error');
                return res.status(200).json({ ok: true, type: 'details_error' });
            }
        }

        // Special Flow Starters (PRESERVED)
        if (userQuery.toLowerCase().trim() === '/contact') {
            await startContactForm(tenant.id, from);
            return res.status(200).json({ ok: true, type: 'contact_form_start' });
        }

        if (userQuery.toLowerCase().trim() === '/feedback') {
            await startFeedbackForm(tenant.id, from);
            return res.status(200).json({ ok: true, type: 'feedback_form_start' });
        }

        if (userQuery.toLowerCase().trim() === '/book_appointment') {
            await startAppointmentBooking(tenant.id, from);
            return res.status(200).json({ ok: true, type: 'appointment_booking_start' });
        }

        // === AI RESPONSE PIPELINE (PRESERVED) ===
        console.log('[DEBUG_FLOW] STEP 6: AI Response Pipeline...');
        console.log('[DEBUG_FLOW] All order processing steps completed - falling back to AI responses');
        
        // Priority 1: Quick Replies
        console.log('[DEBUG_FLOW] Checking quick replies...');
        let quickReplyResponse = null;
        if (typeof findQuickReplyResponse === 'function') {
            quickReplyResponse = await findQuickReplyResponse(tenant.id, userQuery);
            console.log('[DEBUG_FLOW] Quick reply result:', quickReplyResponse ? 'FOUND' : 'NOT_FOUND');
        } else {
            console.warn('[quickReply] findQuickReplyResponse is not a function');
        }
        if (quickReplyResponse) {
            console.log('[DEBUG_FLOW] Quick reply found - sending response');
            await trackResponse(tenant.id, userQuery, 'database', 0.0001);
            await sendAndLogMessage(from, quickReplyResponse, tenant.id, 'quick_reply_response');
            return res.status(200).json({ ok: true, type: 'quick_reply' });
        }

        // Priority 2: Smart FAQ
        console.log('[DEBUG_FLOW] Checking FAQ responses...');
        const faqResponse = await findFaqResponse(tenant.id, userQuery);
        console.log('[DEBUG_FLOW] FAQ result:', faqResponse ? 'FOUND' : 'NOT_FOUND');
        if (faqResponse) {
            console.log('[DEBUG_FLOW] FAQ response found - sending');
            await trackResponse(tenant.id, userQuery, 'database', 0.0001);
            await sendAndLogMessage(from, faqResponse, tenant.id, 'faq_response');
            return res.status(200).json({ ok: true, type: 'faq_response' });
        }

        // Priority 3: Keywords
        console.log('[DEBUG_FLOW] Checking keyword responses...');
        const keywordResponse = await findKeywordResponseSafe(tenant.id, userQuery);
        console.log('[DEBUG_FLOW] Keyword result:', keywordResponse ? 'FOUND' : 'NOT_FOUND');
        if (keywordResponse) {
            const replyText = typeof keywordResponse === 'string' 
                ? keywordResponse 
                : (keywordResponse.reply || keywordResponse.text);
            if (replyText) {
                console.log('[DEBUG_FLOW] Keyword response found - sending');
                await trackResponse(tenant.id, userQuery, 'database', 0.0001);
                await sendAndLogMessage(from, replyText, tenant.id, 'keyword_response');
                return res.status(200).json({ ok: true, type: 'keyword_response' });
            }
        }

        // Priority 4: Product Recommendations
        console.log('[DEBUG_FLOW] Checking product recommendations...');
        const recommendation = await getProductRecommendations(tenant.id, userQuery);
        console.log('[DEBUG_FLOW] Recommendation result:', recommendation ? 'FOUND' : 'NOT_FOUND');
        if (recommendation && !recommendation.startsWith("I'm sorry")) {
            console.log('[DEBUG_FLOW] Product recommendation found - sending');
            await trackResponse(tenant.id, userQuery, 'ai', 0.015);
            await sendAndLogMessage(from, recommendation, tenant.id, 'recommendation_response');
            return res.status(200).json({ ok: true, type: 'product_recommendation' });
        }

        // Priority 5: Human Handover Check
        console.log('[DEBUG_FLOW] Checking for handover requests...');
        const isHandover = await isHandoverRequest(userQuery);
        console.log('[DEBUG_FLOW] Handover check result:', isHandover);
        if (isHandover) {
            console.log('[DEBUG_FLOW] Handover request detected - flagging for human support');
            await flagAndNotifyForHandover(tenant, from);
            const handoverReply = "I've notified a team member. They will get back to you as soon as possible.";
            await sendAndLogMessage(from, handoverReply, tenant.id, 'handover_notice');
            return res.status(200).json({ ok: true, type: 'handover_request' });
        }

        // === HUMAN HANDOVER DETECTION (PRESERVED) ===
        console.log('[DEBUG_FLOW] Checking handover triggers...');
        const hasHandoverTriggers = detectHandoverTriggers(userQuery);
        console.log('[DEBUG_FLOW] Handover triggers result:', hasHandoverTriggers);
        if (hasHandoverTriggers) {
            console.log('[DEBUG_FLOW] Handover triggers detected - setting up context for sales team');
            const context = {
                lastProduct: conversation?.last_product_discussed,
                cartItems: null,
                orderValue: null
            };
            
            // TODO: Implement notifySalesTeam function
            // const handoverSuccess = await notifySalesTeam(tenant, from, userQuery, context);
            const handoverSuccess = true; // Stub for now
            
            if (handoverSuccess) {
                // TODO: Implement sendHandoverResponse function
                // const userLanguage = await detectLanguage(userQuery);
                // const handoverMsg = await sendHandoverResponse(from, tenant.id, userLanguage);
                const handoverMsg = "I've notified our team. They'll assist you shortly.";
                await sendAndLogMessage(from, handoverMsg, tenant.id, 'human_handover');
                return res.status(200).json({ ok: true, type: 'human_handover' });
            }
        }

        // === FINAL AI RESPONSE (PRESERVED) ===
        console.log('[DEBUG_FLOW] STEP 7: Final AI Response (last resort)...');
        console.log('[DEBUG_FLOW] All previous steps failed - generating AI response');
        
        // Send welcome message for new conversations
        const conversationId = await getConversationId(tenant.id, from);
        if (!conversation && tenant.welcome_message) {
            console.log('[DEBUG_FLOW] New conversation - sending welcome message');
            await sendAndLogMessage(from, tenant.welcome_message, tenant.id, 'welcome_message');
        }

        // Categorize and update conversation
        console.log('[DEBUG_FLOW] Categorizing conversation...');
        const category = await categorizeResponse(userQuery);
        await updateConversationCategory(tenant.id, from, category);
        console.log('[DEBUG_FLOW] Conversation category:', category);

        debug.trace(req._rid, 'ai.prepare', { 
            fast: process.env.AI_MODEL_FAST, 
            smart: process.env.AI_MODEL_SMART 
        });

        // Language detection
        console.log('[DEBUG_FLOW] Detecting language...');
        const userLanguage = await detectLanguage(userQuery);
        console.log('[LANGUAGE] Detected language:', userLanguage, 'for query:', userQuery);

        // === FOLLOW-UP SCHEDULING (PRESERVED) ===
        console.log('[DEBUG_FLOW] Checking for follow-up scheduling...');
        const followUpResult = await handleFollowUpRequest(tenant.id, from, userQuery, userLanguage);
        console.log('[DEBUG_FLOW] Follow-up result:', {
            handled: followUpResult.handled,
            followUpId: followUpResult.followUpId,
            scheduledTime: followUpResult.scheduledTime
        });
        if (followUpResult.handled) {
            console.log('[DEBUG_FLOW] Follow-up scheduled - sending confirmation');
            await sendAndLogMessage(from, followUpResult.response, tenant.id, 'followup_scheduled');
            try {
                const contextData = safeParseContextData(conversation.context_data);
                if (contextData.offeredDiscount && contextData.offeredDiscount > 0) {
                    console.log('[DISCOUNT_NEG] Applying approved discount to cart:', contextData.offeredDiscount + '%');
                    // Apply per-item discount using cartService
                    await applyApprovedDiscountToCart(tenant.id, from);
                }
            } catch (metadataError) {
                console.warn('[DISCOUNT_NEG] Error parsing conversation context_data:', metadataError.message);
            }
            return res.status(200).json({ ok: true, type: 'followup_scheduled' });
            try {
                const updateData = {
                   
                    last_product_discussed: productName,
                    state: userQuery.includes('price') || userQuery.includes('final') ? 'pricing_inquiry' : 'product_inquiry',
                    order_context: { 
                        product: productName, 
                        last_query: userQuery,
                        timestamp: new Date().toISOString()
                    }
                };
                
                await supabase
                    .from('conversations')
                    .update(updateData)
                    .eq('tenant_id', tenant.id)
                    .eq('end_user_phone', from);
                    
                console.log('[CONTEXT] Saved product context:', updateData);
                
            } catch (error) {
                console.warn('Failed to save enhanced product context:', error.message);
            }
        }

        // Context-aware final price handling (PRESERVED)
        if (userQuery.toLowerCase().includes('final price') || userQuery.toLowerCase().includes('final')) {
            try {
                const recentMessages = await getConversationHistory(tenant.id, from, 5);
                
                const productMention = recentMessages.find(msg => 
                    msg.message_text && /NFF \d+x\d+|8x100|10x100|\b\d+x\d+\b/i.test(msg.message_text)
                );
                
                if (productMention) {
                    const productMatch = productMention.message_text.match(/(NFF \d+x\d+|\d+x\d+)/i);
                    if (productMatch) {
                        const contextProductName = productMatch[0];
                        
                        try {
                            const { data: product } = await supabase
                                .from('products')
                                .select('price, name')
                                .eq('tenant_id', tenant.id)
                                .or(`name.ilike.%${contextProductName}%,description.ilike.%${contextProductName}%`)
                                .eq('is_active', true)
                                .limit(1)
                                .single();

                            if (product) {
                                const contextualResponse = userLanguage === 'hinglish' ? 
                                    `${contextProductName} ka final price â‚¹${product.price} hai. Order place karna hai?` :
                                    `Final price for ${contextProductName} is â‚¹${product.price}. Would you like to place an order?`;
                                
                                await sendAndLogMessage(from, contextualResponse, tenant.id, 'contextual_pricing');
                                return res.status(200).json({ ok: true, type: 'contextual_response' });
                            }
                        } catch (dbError) {
                            console.warn('Could not fetch product price:', dbError.message);
                        }
                    }
                }
            } catch (error) {
                console.warn('Error in contextual final price handling:', error.message);
            }
        }


                // Modularized AI prompt and fallback logic
                const { createDynamicAIPrompt, getFallbackAIResponse } = require('./customer/aiPrompt');
                await getFallbackAIResponse(tenant, userQuery, userLanguage, conversation, supabase, sendAndLogMessage, res);
                // === DEFAULT GREETING FALLBACK ===
                if (!res.headersSent) {
                    // Default greeting response
                    const customerProfile = await getCustomerProfile(tenant.id, from);
                    const greeting = `Hello ${customerProfile?.first_name || 'there'}! ðŸ‘‹\n\nHow can I help you today?\n\nYou can:\nâ€¢ Browse products\nâ€¢ Place an order\nâ€¢ Check order status\nâ€¢ Ask questions`;
                    await sendAndLogMessage(from, greeting, tenant.id, 'default_greeting');
                    console.log('[DEBUG_FLOW] Sent default greeting response');
                    return res.status(200).json({ ok: true, type: 'default_greeting' });
                }
                return;

    } catch (error) {
        console.error('[DEBUG_FLOW] =====================================');
        console.error('[DEBUG_FLOW] CRITICAL ERROR IN PROCESSING FLOW');
        console.error('[DEBUG_FLOW] Error message:', error.message);
        console.error('[DEBUG_FLOW] Error stack:', error.stack);
        console.error('[DEBUG_FLOW] User query:', userQuery);
        console.error('[DEBUG_FLOW] Tenant ID:', tenant?.id);
        console.error('[DEBUG_FLOW] From:', from);
        console.error('[DEBUG_FLOW] =====================================');
        
        console.error('[CUSTOMER_HANDLER] Error:', error);
        debug.traceErr(req._rid, 'customer.handler', error);
        
        // Emergency fallback response
        const emergencyMessage = "I'm sorry, I'm having trouble processing your message right now. Please try again in a moment.";
        console.log('[DEBUG_FLOW] Sending emergency fallback message...');
        
        try {
            await sendMessage(from, emergencyMessage);
            console.log('[DEBUG_FLOW] Emergency message sent successfully');
        } catch (sendError) {
            console.error('[DEBUG_FLOW] Failed to send emergency message:', sendError.message);
        }
        
        console.log('[DEBUG_FLOW] Returning error response to client');
        return res.status(200).json({ ok: false, error: 'processing_failed' });
    }
}

module.exports = {
    // ... your existing exports
    handleCustomer,
    handleInvoiceRequest,
    handleZohoStatusCommand
};
